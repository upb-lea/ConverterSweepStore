# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'initializeWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import threading
from PyQt5.QtWidgets import QApplication,QMainWindow,QMessageBox
import matplotlib.pyplot as plt
from copy import deepcopy
import math
import itertools
from PyQt5 import QtCore,uic, QtGui
from PyQt5.QtGui import QIcon, QPixmap
from thermalParamClass import thermalParamClass
from collections import defaultdict,Counter
import pyqtgraph as pg
import functools
import re
import os
import numpy as np
import pandas as pd
#from pandasgui import show
from startConnection import startConnection 
from dataBaseClass import dataBaseClass
opLabelAppend = ''
class MainWindow(QMainWindow):
    invfilepath = r'calc\results.pk'
    afefilepath = r'calc_AFE\results.pk'
    Tfilepath = r'..\Thermal\params.csv'
    datasheetpath = r'..\Thermal\DatasheetDB.csv'
    ## Make all plots clickable
    clickedPen = pg.mkPen('b', width=2)
    igbtList = {'B6':['IG1','IG2'],'NPC':['IG1','IG2','IG3','IG4'],'TNPC':['IG1','IG2','IG3','IG4'],'FC-ANPC':['IG1','IG2','IG3','IG4','IG5','IG6','IG7','IG8']}
    diodeList = {'B6':['D1','D2'],'NPC':['D1','D2','D3','D4','D5','D6'],'TNPC':['D1','D2','D3','D4'],'FC-ANPC':['D1','D2','D3','D4','D5','D6','D7','D8']}
    xDataInvList = {'V_DC':['Load_S','f_s','Load_phi','Datasheet'],'Load_S':['V_DC','f_s','Load_phi','Datasheet'],'f_s':['V_DC','Load_S','Load_phi','Datasheet'],'Load_phi':['V_DC','Load_S','f_s','Datasheet'],'Datasheet':['V_DC','Load_S','f_s','Load_phi']}
    xDataAFEList = {'V_DC':['Mains_S','f_s','Mains_phi','Datasheet'],'Mains_S':['V_DC','f_s','Mains_phi','Datasheet'],'f_s':['V_DC','Mains_S','Mains_phi','Datasheet'],'Mains_phi':['V_DC','Mains_S','f_s','Datasheet'],'Datasheet':['V_DC','Mains_S','f_s','Mains_phi']}
    filterList = []
    topologyList = ['B6','NPC','TNPC','FC-ANPC']        
    lastClicked = []
    linAnnotKeys = []
    xList = []
    data2plot ={}
    filter = {}
    rePlotInfo = {}
    def __init__(self,parent =None): 
        super(MainWindow,self).__init__(parent)
        uic.loadUi('GUI\initializeWindow.ui',self)
        _translate = QtCore.QCoreApplication.translate
        self.setWindowIcon(QIcon('Images\\clienticon.png'))
        self.setWindowTitle(_translate("MainWindow", "Converter Sweep Store"))
        app.aboutToQuit.connect(self.closeEvent)
        self.simulateBtn.clicked.connect(self.simulate)
        self.dataBaseWindow = None
        self.thermalWindow = None
        self.showGSIMS.stateChanged.connect(self.showGSIMSData)
        self.tabWidget.currentChanged.connect(self.onChange)
        self.progressBar.hide()
        self.progressBar.reset()
        self.databaseBtn.clicked.connect(self.openDataBase) 
        self.pandasGUIBtn.clicked.connect(self.openPandasGUI)
        self.toolButtonThermal.clicked.connect(self.loadThermalBox)
        self.toolButtonThermal.setAutoRaise(True)
        self.plotControls.hide()
        self.optRangeControls.hide()
        self.cid = self.MplWidget.canvas.mpl_connect('motion_notify_event', self.hover) 
        self.buttonGroupScatterData.setId(self.invTotalRadio,1)
        self.buttonGroupScatterData.setId(self.invIgbtRadio,2)
        self.buttonGroupScatterData.setId(self.invDiodeRadio,3)
        self.buttonGroupRangeType.setId(self.optPinToolBtn,1)
        self.buttonGroupRangeType.setId(self.optVdcToolBtn,2)
        self.buttonGroupRangeType.setId(self.optSwToolBtn,3)
        self.buttonGroupRangeType.buttonClicked[int].connect(self.rangeAndUpdate)
        self.scDiodeCombo.textActivated.connect(self.scComboboxChanged)
        self.scIgbtCombo.textActivated.connect(self.scComboboxChanged)
        self.opComboType.textActivated.connect(self.updateOpBtnLabel)
        self.buttonGroupTopology.buttonClicked.connect(self.loadDataSheets)
        self.buttonGroupPlotType.buttonClicked.connect(self.selectPlotType)
        self.buttonGroupScatterData.buttonClicked.connect(self.updateScatterRadios)
        self.buttonGroupMode.buttonClicked.connect(self.updateAfeLabels)
        self.opAddBtn.clicked.connect(self.addFilterCriteria)
        self.themeToggler.clicked.connect(self.changeTheme)
        self.plotBtn.clicked.connect(self.validateFilter)
        self.optInvBtn.setChecked(True)
        self.plotInvBtn.setChecked(True)
        self.InverterModeBtn.setChecked(True)
        self.buttonGroupPlotMode.buttonClicked.connect(self.plotChangeDb)
        self.buttonGroupOptMode.buttonClicked.connect(self.optChangeDb)
        self.opClearBtn.clicked.connect(self.clear)
        self.searchOptBtn.clicked.connect(self.findOptimum)
        self.topologyCombo.insertItems(0,self.topologyList)
        self.topologyCombo.textActivated.connect(self.resetControls)
        self.xDatacomboBox.textActivated.connect(self.replotScatter)
        self.tempSlider.valueChanged.connect(self.updateTempLabel)
        self.tempDispBtn.clicked.connect(self.lockTemp)
        self.sc = {}
        self.themeFlag = False
        self.PinRangeSelector.hide()
        self.VdcRangeSelector.hide()
        self.SwRangeSelector.hide()
        self.gridLayoutWidget.hide()
        self.VdcRangeSelector.setBackgroundStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #222, stop:1 #333);')
        self.VdcRangeSelector.setSpanStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #282, stop:1 #393);')
        self.VdcRangeSelector.setStyleSheet("""
        QRangeSlider > QSplitter::handle {
            background: #777;
            border: 1px solid #555;
        }
        QRangeSlider > QSplitter::handle:vertical {
            height: 2px;
        }
        QRangeSlider > QSplitter::handle:pressed {
            background: #ca5;
        }
        """)
        self.PinRangeSelector.setBackgroundStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #222, stop:1 #333);')
        self.PinRangeSelector.setSpanStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #282, stop:1 #393);')
        self.PinRangeSelector.setStyleSheet("""
        QRangeSlider > QSplitter::handle {
            background: #777;
            border: 1px solid #555;
        }
        QRangeSlider > QSplitter::handle:vertical {
            height: 2px;
        }
        QRangeSlider > QSplitter::handle:pressed {
            background: #ca5;
        }
        """)
        self.SwRangeSelector.setBackgroundStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #222, stop:1 #333);')
        self.SwRangeSelector.setSpanStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #282, stop:1 #393);')
        self.SwRangeSelector.setStyleSheet("""
        QRangeSlider > QSplitter::handle {
            background: #777;
            border: 1px solid #555;
        }
        QRangeSlider > QSplitter::handle:vertical {
            height: 2px;
        }
        QRangeSlider > QSplitter::handle:pressed {
            background: #ca5;
        }
        """)
        self.checkDatabase()
        self.loadDataSheets()
        timer = QtCore.QTimer(self, interval=1000, timeout=self.showTime)
        timer.start()
        self.showTime()

    def changeTheme(self) :
        if not self.themeFlag:
            self.themeToggler.setText('Dark')
            self.themeToggler.setStyleSheet("background-color: rgb(86,86,86);border: 2px solid rgb(3,194,252); color : rgb(3,194,252)")
            self.databaseBtn.setStyleSheet("background-color: rgb(33, 133, 148);color:white")
            self.pandasGUIBtn.setStyleSheet("background-color: rgb(33, 133, 148);color:white")
            self.simulateBtn.setStyleSheet("background-color: rgb(33, 133, 148);color:white")
            self.searchOptBtn.setStyleSheet("background-color: rgb(33, 133, 148);color:white")
            self.plotBtn.setStyleSheet("background-color: rgb(33, 133, 148);color:white")
            self.dataSheetComboBox.setStyleSheet("background-color: rgb(33, 133, 148);color:white")
            palette = getPalette()
        else :
            self.themeToggler.setText('Light')
            self.themeToggler.setStyleSheet("")
            self.databaseBtn.setStyleSheet("")
            self.pandasGUIBtn.setStyleSheet("")
            self.simulateBtn.setStyleSheet("")
            self.searchOptBtn.setStyleSheet("")
            self.plotBtn.setStyleSheet("")
            self.dataSheetComboBox.setStyleSheet("")
            palette = QtGui.QPalette()
        if self.dataBaseWindow is not None:
            self.dataBaseWindow.setPalette(palette)
        if self.thermalWindow is not None:
            self.thermalWindow.setPalette(palette)
        self.setPalette(palette)   
        self.themeFlag = not self.themeFlag
    
    def updateTempLabel(self, value):
        if value:
            self.tempDispBtn.setText(str(value)+'° C')
        else :
            self.tempDispBtn.setText('All')

    def lockTemp(self, state):
        if state :
            self.tempSlider.setEnabled(False)
            self.controlFrame.setEnabled(True)
            self.replotScatter()
        elif not state :
            self.tempSlider.setEnabled(True)
            self.controlFrame.setEnabled(False)

    def closeEvent(self,val) :
        sys.exit(0)

    def checkDatabase(self):
        mode =''
        fileInv = os.path.exists(self.invfilepath)
        fileAfe = os.path.exists(self.afefilepath)
        if not (fileInv and fileAfe):
            IGBTColumnList = ['IG1_con','IG1_sw','IG2_con','IG2_sw','IG3_con','IG3_sw','IG4_con','IG4_sw','IG5_con','IG5_sw','IG6_con','IG6_sw','IG7_con','IG7_sw','IG8_con','IG8_sw']
            DiodeColumnList = ['D1_con','D1_sw','D2_con','D2_sw','D3_con','D3_sw','D4_con','D4_sw','D5_con','D5_sw','D6_con','D6_sw','D7_con','D7_sw','D8_con','D8_sw']
            TotalColumnList = ['file','ConvTotalLoss','IG1','IG2','IG3','IG4','IG5','IG6','IG7','IG8','D1','D2','D3','D4','D5','D6','D7','D8']
            TempColumnList = ['Igbt1Temp','Igbt2Temp','Igbt5Temp','Igbt7Temp','D1Temp','D2Temp','D5Temp','D7Temp']  
            if not fileInv:
                InvOperatingList = ['Topology','Datasheet','V_DC','Load_S','Load_phi','f_s','T_HS','f_out','Status','TransformerLoss']#13
                columns_list = InvOperatingList+TotalColumnList+TempColumnList+IGBTColumnList+DiodeColumnList + ['_run_id','_pset_id','_calc_dir','_time_utc']
                df = pd.DataFrame(columns=columns_list)
                df.to_pickle(self.invfilepath)
            if not fileAfe :
                AfeOperatingList = ['Topology','Datasheet','V_DC','Mains_S','Mains_phi','f_s','T_HS','f_out','Status','TransformerLoss']
                columns_list = AfeOperatingList+TotalColumnList+TempColumnList+IGBTColumnList+DiodeColumnList+ ['_run_id','_pset_id','_calc_dir','_time_utc']
                df = pd.DataFrame(columns=columns_list)
                df.to_pickle(self.afefilepath)
        df_inv = pd.read_pickle(self.invfilepath)
        df_afe = pd.read_pickle(self.afefilepath)
        if (df_inv.empty and df_afe.empty) :
            self.tabWidget.setTabEnabled(1, False)
            self.tabWidget.setTabEnabled(2, False)
        elif(not df_inv.empty) :
            mode = 'Inverter'
            self.InverterModeBtn.setChecked(True)
            self.loadPrevParams(self.invfilepath,mode)
            self.initializeTabControls(mode)
        elif(not df_afe.empty):
            mode = 'AFE'
            self.AFEModeBtn.setChecked(True)
            self.loadPrevParams(self.afefilepath, mode)
            self.initializeTabControls(mode)

    def loadDataSheets(self):
        topology = self.buttonGroupTopology.checkedButton().text()
        pixmap = QPixmap('Images\\'+topology+'.png')
        self.topologyPicture.setPixmap(pixmap)
        self.topologyPicture.setScaledContents(True)
        self.dataSheetComboBox.clear()
        df = pd.read_csv(self.datasheetpath)
        datasheets = df[df['Topology'] == topology]['Datasheet'].tolist()
        self.dataSheetComboBox.insertItems(0,datasheets)
   
    def openPandasGUI(self) :
        df = pd.read_pickle(self.invfilepath)
        show(df)

    def conjunction(*conditions):
        return functools.reduce(np.logical_and, conditions)

    def clear(self):
        self.filter = {}
        self.opSelectDisplayLabel.clear()
        self.opAddBtn.setText('Add')
        self.opErrorLabel.setStyleSheet("")
        self.opErrorLabel.clear()
    
    def updateAfeLabels(self,button):
        if button.text()=='AFE':
            self.loadWLabel.setText("Mains in VA       :")
            self.loadVltg.setText("Mains Voltage       :")
            self.loadZ.setText("Load Inv(Z_inv) :")
            self.loadPrevParams(self.afefilepath,'AFE')
            self.updateGSIMS(False)
        else :
            self.loadWLabel.setText("Load in VA        :")
            self.loadVltg.setText("Load Voltage       :")
            self.loadZ.setText("Load Imp(Z_L)  :")
            self.loadPrevParams(self.invfilepath,'Inverter')
            self.updateGSIMS(False)

    def plotChangeDb(self,button, isDFUpdated = None):
        plotTopology = self.topologyCombo.currentText()
        plotMode = button.text()
        if plotMode =='AFE':
           df_all = pd.read_pickle(self.afefilepath)
           self.xDatacomboBox.clear()
           self.xDatacomboBox.addItems(self.xDataAFEList.keys())
        elif plotMode == 'Inverter':
           df_all = pd.read_pickle(self.invfilepath)
           self.xDatacomboBox.clear()
           self.xDatacomboBox.addItems(self.xDataInvList.keys())
        self.plot_df = df_all[(df_all['Topology']==plotTopology) & (df_all['Status']=='Ok')].copy()
        self.plot_df['SwitchTmax'] = self.plot_df[['Igbt1Temp','Igbt2Temp','Igbt5Temp','Igbt7Temp']].max(axis=1)
        self.plot_df['DiodeTmax'] = self.plot_df[['D1Temp','D2Temp','D5Temp','D7Temp']].max(axis=1)
        self.xAxisChanged('V_DC')
        if not isDFUpdated :
            self.replotScatter() 

    def replotScatter(self):
        self.clear()
        if len(self.rePlotInfo) == 3 and self.rePlotInfo['plotType'] == 'Scatter':
          self.updateScatterRadios(self.rePlotInfo['LossTypeBtn'])
        
    def xAxisChanged(self,xAxisLabel=None):
        self.clear()
        plotMode = self.buttonGroupPlotMode.checkedButton().text()
        self.filterList.clear()
        if plotMode == 'Inverter':
            self.filterList = deepcopy(self.xDataInvList[xAxisLabel])
        elif plotMode == 'AFE':
            self.filterList = deepcopy(self.xDataAFEList[xAxisLabel])
        self.filter.clear()
        self.opComboType.clear()
        self.opComboType.insertItems(0,self.filterList)

    def optChangeDb(self,button, isDFUpdated=None):
        optMode = button.text()
        self.opt_df = pd.DataFrame(None)
        if optMode =='AFE':
            df_all = pd.read_pickle(self.afefilepath)
            self.opt_df = df_all[(df_all['Status']=='Ok')].copy()
            self.opt_df['PWatts'] = round(self.opt_df['Mains_S']* self.opt_df['Mains_phi'].apply(math.cos))
        else:
            df_all = pd.read_pickle(self.invfilepath)
            self.opt_df = df_all[(df_all['Status']=='Ok')].copy()
            self.opt_df['PWatts'] = round(self.opt_df['Load_S']* self.opt_df['Load_phi'].apply(math.cos))
        if not isDFUpdated:
            self.optStatusLabel.setStyleSheet("")  #check the position
            self.optStatusLabel.clear()
            self.OptimalChartArea.canvas.figure.set_visible(False)
            self.OptimalChartArea.toolbar.show()
            self.OptimalChartArea.canvas.draw()
            self.rangeAndUpdate() #UPDATES all sliders irrespective of visibility of each slider everytime db gets changed
        

    def updateOpBtnLabel(self):
        key = self.opComboType.currentText()
        if key in self.filter:
            self.opAddBtn.setText('Update')
        else:
            self.opAddBtn.setText('Add')

    @QtCore.pyqtSlot()
    def showTime(self):
        CurrTime = QtCore.QTime.currentTime()
        text = CurrTime.toString("HH mm ss" if CurrTime.second() % 2 == 0 else "HH:mm:ss")
        self.lcdDateTime.display(text)

    def rangeAndUpdate(self,id=None): 
        if not self.opt_df.empty:
            vdcMinReq =  185
            vdcMaxReq = 260
            vdcNominal = 216
            fsMaxReq = 14400
            fsMinReq = 7200
            fsNominal = 10800
            pWNomial = 32000
            def findRange(Min,Max,MinReq,MaxReq):
                if(MinReq > Min):
                    Min = MinReq
                if(MaxReq < Max):
                    Max = MaxReq
                return Max,Min
            vDcMax = self.opt_df['V_DC'].max()
            vDcMin = self.opt_df['V_DC'].min()
            fsMax = self.opt_df['f_s'].max()    
            fsMin = self.opt_df['f_s'].min()
            pWMax = self.opt_df['PWatts'].max()
            pWMin = self.opt_df['PWatts'].min()
            setVDcMax,setVDcMin = findRange(vDcMin,vDcMax,vdcMinReq,vdcMaxReq)
            setFsMax,setFsMin = findRange(fsMin,fsMax,fsMinReq,fsMaxReq)
            setPWMax,setPWMin = findRange(pWMin,pWMax,10000,pWNomial)
            btnOptions = { 1:{'rangeBtn':self.PinRangeSelector,'inputBtn':self.optPinInput,'Max':pWMax,'Min':pWMin,'rangeMin':setPWMin,'rangeMax':setPWMax,'normValue':1000,'decimalValue':1},
                           2:{'rangeBtn':self.VdcRangeSelector,'inputBtn':self.optVdcInput,'Max':vDcMax,'Min':vDcMin,'rangeMin':setVDcMin,'rangeMax':setVDcMax},
                           3:{'rangeBtn':self.SwRangeSelector,'inputBtn':self.optSwInput,'Max':fsMax,'Min':fsMin,'rangeMin':setFsMin,'rangeMax':setFsMax,'normValue':1000,'decimalValue':1}
                          }
            if id is None :
                for slider in btnOptions:
                    self.updateSlider(**btnOptions[slider])
            else :
                self.toggleInput(**btnOptions[id])
            self.searchOptBtn.setEnabled(True)
        else:
            self.searchOptBtn.setEnabled(False)
            self.PinRangeSelector.hide()
            self.VdcRangeSelector.hide()
            self.SwRangeSelector.hide()
            self.optPinInput.clear()
            self.optPinInput.show()
            self.optVdcInput.clear()
            self.optVdcInput.show()
            self.optSwInput.clear()
            self.optSwInput.show()
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText('Database is Empty!')
            msgBox.exec() 
   
    def findOptimum(self):
        searchSeries = {}
        plotDFCollection = {}
        refinedDFs = {}
        searchValue = []
        errorMsg = ''
        self.optStatusLabel.setStyleSheet("")  #check the position
        self.optStatusLabel.clear()
        self.NPCTempHouse.setEnabled(False)
        self.B6TempHouse.setEnabled(False)
        self.TNPCTempHouse.setEnabled(False)
        self.ANPCTempHouse.setEnabled(False)
        self.OptimalChartArea.canvas.figure.clf()
        self.OptimalChartArea.canvas.draw_idle()
        if not 'PWatts' in self.opt_df.columns:
            if self.buttonGroupOptMode.checkedButton().text() == 'AFE':
                self.opt_df['PWatts'] = round(self.opt_df['Mains_S']* self.opt_df['Mains_phi'].apply(math.cos))
            else :
                self.opt_df['PWatts'] = round(self.opt_df['Load_S']* self.opt_df['Load_phi'].apply(math.cos))

        def searchOptBtn(topology, rangeBtn,column, df,buttonInput,normalizeValue =1):
            if rangeBtn.isVisible(): 
                range = rangeBtn.getRange()
                actual_range = tuple([normalizeValue*x for x in range])
                searchValue = list(actual_range)
                filterSeries = df[column].between(*actual_range)
            else:
                searchValue = float(buttonInput.text())
                filterSeries = df[column]==searchValue
            isAValidSeries = filterSeries.sum()                                
            if not isAValidSeries:
                raise Exception("\n{} :{} = {} not found".format(''.join(topology),''.join(column),''.join(str(searchValue))))
            else : 
                return filterSeries
       
        for topology in self.topologyList:
            try :
                topology_df = self.opt_df[self.opt_df['Topology']== topology]
                searchSeries['pSearchSeries'] = searchOptBtn(topology,self.PinRangeSelector,'PWatts',topology_df, self.optPinInput,1000)
                searchSeries['vDcSearchSeries'] = searchOptBtn(topology,self.VdcRangeSelector,'V_DC',topology_df,self.optVdcInput)
                searchSeries['sWSearchSeries'] = searchOptBtn(topology,self.SwRangeSelector,'f_s',topology_df,self.optSwInput,1000)
            except ValueError:
                self.optStatusLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
                self.optStatusLabel.setText("Please check the inputs provided")
                self.optStatusLabel.adjustSize()
                break
            except Exception as e:
                errorMsg = errorMsg + str(e.args[0])
                self.optStatusLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
                self.optStatusLabel.setText(errorMsg)
                self.optStatusLabel.adjustSize()
                print(str(e.args[0]))
            else :
                seriesBoolReturns = list(searchSeries.values())
                plotDFCollection[topology] = topology_df[self.conjunction(*seriesBoolReturns)]
        if len(plotDFCollection) >0:
            refinedDFs =  plotDFCollection
            for topology in list(plotDFCollection):  #to avoid runtime error 
                try :
                    if refinedDFs[topology].empty :
                        del refinedDFs[topology]
                        raise Exception(topology+": Range not in DBase \n")
                except Exception as e:   
                    errorMsg = errorMsg + str(e.args[0])
                    self.optStatusLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
                    self.optStatusLabel.setText(errorMsg)
                    self.optStatusLabel.adjustSize()
        if len(refinedDFs) >0:
            self.processAndMaptoFigure(refinedDFs)
            

    def processAndMaptoFigure(self,dfsCollected):
        dfToBar = {}
        opPoint = {}
        rcdTemps = {}
        for topology in dfsCollected:
            df = dfsCollected[topology]
            finalRow = df[df['ConvTotalLoss']==df['ConvTotalLoss'].min()].to_dict('records')[0]
            opPoint[topology] = finalRow
            if topology == 'NPC':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con'],finalRow['D5_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw'],finalRow['D5_sw']]
                rcdTemps[topology] = [finalRow['Igbt1Temp'],finalRow['Igbt2Temp'],finalRow['D1Temp'],finalRow['D2Temp'],finalRow['D5Temp']]
                index  = ['T1/T4','D1/D4','T2/T3','D2/D3','D5/D6']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
            elif topology == 'TNPC':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw']]
                rcdTemps[topology] = [finalRow['Igbt1Temp'],finalRow['Igbt2Temp'],finalRow['D1Temp'],finalRow['D2Temp']]
                index  = ['T1/T4','D1/D4','T2/T3','D2/D3']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
            elif topology == 'B6':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw']]
                rcdTemps[topology] = [finalRow['Igbt1Temp'],finalRow['Igbt2Temp'],finalRow['D1Temp'],finalRow['D2Temp']]
                index  = ['T1','D1','T2','D2']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
            elif topology == 'FC-ANPC':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con'],finalRow['IG6_con'],finalRow['D6_con'],finalRow['IG8_con'],finalRow['D8_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw'],finalRow['IG6_sw'],finalRow['D6_sw'],finalRow['IG8_sw'],finalRow['D8_sw']]
                rcdTemps[topology] = [finalRow['Igbt1Temp'],finalRow['Igbt2Temp'],finalRow['Igbt5Temp'],finalRow['Igbt7Temp'],finalRow['D1Temp'],finalRow['D2Temp'],finalRow['D5Temp'],finalRow['D7Temp']]
                index  = ['T1/T4','D1/D4','T2/T3','D2/D3','T5\T6','D5\D6','T7\T8','D7\D8']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
        self.clearTempEdits()
        self.loadIntoTempEdits(rcdTemps)
        plotNum = len(dfToBar)
        if plotNum == 1:
           self.OptimalChartArea.plotOne(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText('Only '+ str(list(dfToBar.keys())[0]) + ' exists in Range')
        if plotNum == 2:
           self.OptimalChartArea.plotTwo(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText('Only '+ list(dfToBar.keys())[0]+', '+list(dfToBar.keys())[1] + ' exists in Range')
        if plotNum == 3:
           self.OptimalChartArea.plotThree(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText(str(list(dfToBar.keys())[0])+', '+ list(dfToBar.keys())[1]+', '+list(dfToBar.keys())[2]  + ' exists in Range')
        if plotNum == 4:
           self.OptimalChartArea.plotFour(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText(str(list(dfToBar.keys())[0])+', '+ list(dfToBar.keys())[1]+', '+list(dfToBar.keys())[2] +', '+list(dfToBar.keys())[3] + ' exists in Range')
        
    def clearTempEdits(self):
        self.IG1TpEdit_NPC.clear()
        self.IG2TpEdit_NPC.clear()
        self.D1TpEdit_NPC.clear()
        self.D2TpEdit_NPC.clear()
        self.D5TpEdit_NPC.clear()
        self.IG1TpEdit_B6.clear()
        self.IG2TpEdit_B6.clear()
        self.D1TpEdit_B6.clear()
        self.D2TpEdit_B6.clear()
        self.IG1TpEdit_TNPC.clear()
        self.IG2TpEdit_TNPC.clear()
        self.D1TpEdit_TNPC.clear()
        self.D2TpEdit_TNPC.clear()
        self.IG1TpEdit_ANPC.clear()
        self.IG2TpEdit_ANPC.clear()
        self.IG5TpEdit_ANPC.clear()
        self.IG7TpEdit_ANPC.clear()
        self.D1TpEdit_ANPC.clear()
        self.D2TpEdit_ANPC.clear()
        self.D5TpEdit_ANPC.clear()
        self.D7TpEdit_ANPC.clear()

    def loadIntoTempEdits(self, rcdTemps):
        for topology in rcdTemps:
            tempList = [round(num, 1) for num in rcdTemps[topology]]
            if topology == 'NPC':
                self.NPCTempHouse.setEnabled(True)
                self.IG1TpEdit_NPC.setText(str(tempList[0]))
                self.IG2TpEdit_NPC.setText(str(tempList[1]))
                self.D1TpEdit_NPC.setText(str(tempList[2]))
                self.D2TpEdit_NPC.setText(str(tempList[3]))
                self.D5TpEdit_NPC.setText(str(tempList[4]))
            if topology == 'B6':
                self.B6TempHouse.setEnabled(True)
                self.IG1TpEdit_B6.setText(str(tempList[0]))
                self.IG2TpEdit_B6.setText(str(tempList[1]))
                self.D1TpEdit_B6.setText(str(tempList[2]))
                self.D2TpEdit_B6.setText(str(tempList[3]))
            if topology == 'TNPC':
                self.TNPCTempHouse.setEnabled(True)
                self.IG1TpEdit_TNPC.setText(str(tempList[0]))
                self.IG2TpEdit_TNPC.setText(str(tempList[1]))
                self.D1TpEdit_TNPC.setText(str(tempList[2]))
                self.D2TpEdit_TNPC.setText(str(tempList[3]))
            if topology == 'FC-ANPC':
                self.ANPCTempHouse.setEnabled(True)
                self.IG1TpEdit_ANPC.setText(str(tempList[0]))
                self.IG2TpEdit_ANPC.setText(str(tempList[1]))
                self.IG5TpEdit_ANPC.setText(str(tempList[2]))
                self.IG7TpEdit_ANPC.setText(str(tempList[3]))
                self.D1TpEdit_ANPC.setText(str(tempList[4]))
                self.D2TpEdit_ANPC.setText(str(tempList[5]))
                self.D5TpEdit_ANPC.setText(str(tempList[6]))
                self.D7TpEdit_ANPC.setText(str(tempList[7]))

    def toggleInput(self,rangeBtn,inputBtn,Max,Min,rangeMin,rangeMax,normValue=1,decimalValue=0):
            if rangeBtn.isVisible():
                rangeBtn.hide()
                inputBtn.show()
            else :
                inputBtn.hide() 
                rangeBtn.show()
                self.updateSlider(rangeBtn,inputBtn,Max,Min,rangeMin,rangeMax,normValue,decimalValue)                

    def updateSlider(self,rangeBtn,inputBtn,Max,Min,rangeMin,rangeMax,normValue= 1,decimalValue = 0):
                if Max == Min:
                    inputBtn.show()
                    inputBtn.setText(str(Max))
                    rangeBtn.hide()
                    return
                rangeBtn.setMin(round(Min/normValue,decimalValue))
                rangeBtn.setMax(round(Max/normValue,decimalValue))
                rangeBtn.setRange(round(rangeMin/normValue,decimalValue),round(rangeMax/normValue,decimalValue))
                
    def validateFilter(self) :
        try :
            selected = self.rePlotInfo['LossType']
        except KeyError:
            selected = None
            pass
        try :
            filtString = {}
            switchTypekeys = list()
            self.opErrorLabel.clear()
            self.opErrorLabel.setStyleSheet("")
            isTempScaleReq = self.tempScaleBtn.isChecked()
            resultDF = pd.DataFrame(None)
            if not selected : 
                if isTempScaleReq:
                    raise Exception("select the device type")
                else  : 
                    raise Exception("select the loss type")
            if len(self.filter) < 3 :
                raise Exception("min 3 filters required")
            elif len(self.filter) == 3 or len(self.filter) == 4:
                for key in self.filter :
                   filtString[key] =  (self.plot_df[key] == self.filter[key])
                   if not filtString[key].values.sum():
                        raise Exception("{} = {} not found".format(''.join(key),''.join(str(self.filter[key]))))
            conditionsBoolReturns = list(filtString.values())
            resultDF = self.plot_df[self.conjunction(*conditionsBoolReturns)]
            heatSinkTemp = self.tempSlider.value()
            if heatSinkTemp:
                resultDF = resultDF[resultDF['T_HS']==heatSinkTemp]
            if resultDF.empty :
                raise Exception("Not in DB, Check Temp° \ OPoint")
            index = set(self.filterList)- self.filter.keys()
            key =  self.filterList[2] if index == set() else index.pop()
            xkey = self.xDatacomboBox.currentText()
            switchTypekeys = getSelectionKey(selected) if isTempScaleReq else [selected]
            self.makeLinearPlot(resultDF, switchTypekeys, xkey, key)
        except Exception as e:
            self.opErrorLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
            self.opErrorLabel.setText(str(e.args[0]))

    
            
    def selectPlotType(self,button) :
        self.scatterDataBox.setEnabled(True)
        self.xDatacomboBox.setEnabled(True)
        self.xDatacomboBox.setCurrentIndex(0)
        self.rePlotInfo.update({'plotType':button.text()})
        if button.text() == 'Linear':
            self.opPointBox.setEnabled(True)
            self.scatterDataBox.setTitle('Linear Data')
            self.tempScaleBtn.setEnabled(True)
            self.reconnect(self.buttonGroupScatterData.buttonClicked) #disconnecting slots
            self.reconnect(self.invTotalRadio.clicked, self.linComboboxChanged)
            self.reconnect(self.scDiodeCombo.textActivated, self.linComboboxChanged) #changing slots
            self.reconnect(self.scIgbtCombo.textActivated, self.linComboboxChanged)  #changing slots
            self.reconnect(self.xDatacomboBox.textActivated, self.xAxisChanged)
            self.plotBtn.setEnabled(True)
        else :
            self.opPointBox.setEnabled(False)
            self.tempScaleBtn.setEnabled(False)
            self.plotBtn.setEnabled(False)
            self.clear()
            self.scatterDataBox.setTitle('Scatter Data')
            self.reconnect(self.buttonGroupScatterData.buttonClicked,self.updateScatterRadios) #reconnecting slots
            self.reconnect(self.scDiodeCombo.textActivated,self.scComboboxChanged) #reconnecting slots
            self.reconnect(self.scIgbtCombo.textActivated,self.scComboboxChanged) #reconnecting slots
            self.reconnect(self.xDatacomboBox.textActivated, self.replotScatter)
            self.reconnect(self.invTotalRadio.clicked) #disconnecting slot
            self.replotScatter()

           
    def reconnect(self, signal, newhandler=None, oldhandler=None):        
        try:
            if oldhandler is not None:
                while True:
                    signal.disconnect(oldhandler)
            else:
                signal.disconnect()
        except TypeError:
            pass
        if newhandler is not None:
            signal.connect(newhandler)
    
    def makeLinearPlot(self,df,ykeys,xkey,key) :
        self.MplWidget.canvas.axes.clear()
        keyLen = len(ykeys)
        self.linAnnotKeys.clear()
        self.linAnnotKeys= [xkey, ykeys[0]]
        markers = ['o','d']
        for n,ykey in enumerate(ykeys):
            pvtd_df = df.pivot(index=xkey, columns=key, values=ykey)
            ax = pvtd_df.plot(ax= self.MplWidget.canvas.axes,grid =True, marker=markers[n], kind = 'line')
        if keyLen >1:
            handles, labels = ax.get_legend_handles_labels()
            legendCount = len(labels)
            for n in range(legendCount//2):
                labels[n]=labels[n]+'(SW)'
                legendCount = legendCount -1
                labels[legendCount]= labels[legendCount]+'(D)'
            ax.legend(handles,labels)
        self.sc['linear'] = ax.lines
        self.sc.pop('scatter',None)
        self.annot = self.MplWidget.canvas.axes.annotate("", xy=(0,0), xytext=(20,20),textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="w"),
                            arrowprops=dict(arrowstyle="->"))
        self.annot.set_visible(False)
        self.cid = self.MplWidget.canvas.mpl_connect('motion_notify_event', self.hover)
        self.MplWidget.canvas.axes.set_ylabel(getYisLabel(ykeys[0]))
        self.MplWidget.canvas.axes.set_xlabel(getXisLabel(xkey))
        self.MplWidget.canvas.draw()
        self.MplWidget.canvas.figure.set_visible(True)
        self.MplWidget.toolbar.show()
        print(df)


    def updateScatterRadios(self, button) :         
        yLabel = ''
        xLabel = ''
        xData = []
        yData = []
        tempFilteredDF = pd.DataFrame(None)
        selected = ''
        if button.text() =='Total Inverter Loss' : 
            self.scIgbtCombo.setCurrentIndex(-1) 
            self.scDiodeCombo.setCurrentIndex(-1) 
            selected = 'ConvTotalLoss'
        elif button.text() == 'IGBT ':
            selected = self.scIgbtCombo.currentText()
            self.scDiodeCombo.setCurrentIndex(-1)
        elif button.text() == 'Diode':
            selected = self.scDiodeCombo.currentText()
            self.scIgbtCombo.setCurrentIndex(-1) 
        xAxisPoint = self.xDatacomboBox.currentText()   
        if selected :
            heatSinkTemp = self.tempSlider.value()
            tempFilteredDF = self.plot_df[self.plot_df['T_HS']==heatSinkTemp] if heatSinkTemp else self.plot_df
            self.rePlotInfo.update({'LossTypeBtn':button, 'LossType':selected}) 
            self.data2plot['xData']= {xAxisPoint: list(tempFilteredDF[xAxisPoint])}                
            self.data2plot['yData']= {selected: list(tempFilteredDF[selected].fillna(0))}
            length = len(self.data2plot['yData'][selected])
            xLabel = getXisLabel(xAxisPoint)
            yLabel =  button.text() if 'Loss' in button.text() else button.text()+' Loss'
            self.data2plot['Dataset'] = tempFilteredDF
            self.plotScatter(self.data2plot['xData'],self.data2plot['yData'],xLabel,yLabel,length)

    def scComboboxChanged(self):
        sender = self.sender()
        if sender.objectName() == 'scDiodeCombo':
            self.invDiodeRadio.setChecked(True)
            self.updateScatterRadios(self.invDiodeRadio)
        elif sender.objectName() == 'scIgbtCombo':
            self.invIgbtRadio.setChecked(True)
            self.updateScatterRadios(self.invIgbtRadio)
    
    def linComboboxChanged(self):
        sender = self.sender()
        if sender.objectName() == 'invTotalRadio':
            selected = 'ConvTotalLoss'
            button = self.invTotalRadio
            self.scIgbtCombo.setCurrentIndex(-1) 
            self.scDiodeCombo.setCurrentIndex(-1) 
        elif sender.objectName() == 'scDiodeCombo':
            selected = self.scDiodeCombo.currentText()
            button = self.invDiodeRadio
            self.invDiodeRadio.setChecked(True)
            self.scIgbtCombo.setCurrentIndex(-1)
        elif sender.objectName() == 'scIgbtCombo':
            selected = self.scIgbtCombo.currentText()
            button = self.invIgbtRadio
            self.invIgbtRadio.setChecked(True)
            self.scDiodeCombo.setCurrentIndex(-1)
        self.rePlotInfo.update({'LossType':selected,'LossTypeBtn':button})

    def addFilterCriteria(self):
        try :
            item = str(self.opComboType.currentText())
            if item == 'Datasheet':
                input = str(self.opComboInput.text())
            else:
                input = float(self.opComboInput.text())
            global opLabelAppend
            self.filter[item] = input
            if item in self.filter:
                for key in self.filter :
                    opLabelAppend = opLabelAppend + "{} = {}\n".format("".join(key),"".join(str(self.filter[key])))
            self.opSelectDisplayLabel.setText(opLabelAppend)
            opLabelAppend = ''
            self.opComboInput.clear()
            self.opAddBtn.setText('Update')
        except :
            self.opErrorLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
            self.opErrorLabel.setText("Invalid {} input".format("".join(str(self.opComboType.currentText()))))

    def initializeTabControls(self, DBmode):
        plotTopology = self.topologyCombo.currentText()
        if DBmode == 'Inverter':
            self.optInvBtn.setChecked(True)
            self.plotInvBtn.setChecked(True)
            df_all = pd.read_pickle(self.invfilepath)
            self.opt_df = df_all[(df_all['Status']=='Ok')].copy()
            self.plot_df =  df_all[(df_all['Topology']==plotTopology) & (df_all['Status']=='Ok')].copy()
            self.opt_df['PWatts'] = round(self.opt_df['Load_S']*self.opt_df['Load_phi'].apply(math.cos))
            self.filterList = deepcopy(self.xDataInvList['V_DC'])
            self.opComboType.insertItems(0,self.filterList)
            self.xDatacomboBox.addItems(self.xDataInvList.keys())
        elif DBmode == 'AFE':
            self.optAfeBtn.setChecked(True)
            self.plotAFEBtn.setChecked(True)
            df_all = pd.read_pickle(self.afefilepath)
            self.opt_df = df_all[(df_all['Status']=='Ok')].copy()
            self.plot_df =  df_all[(df_all['Topology']==plotTopology) & (df_all['Status']=='Ok')].copy()
            self.opt_df['PWatts'] = round(self.opt_df['Mains_S']* self.opt_df['Mains_phi'].apply(math.cos))
            self.filterList= deepcopy(self.xDataAFEList['V_DC'])
            self.opComboType.insertItems(0,self.filterList)
            self.xDatacomboBox.addItems(self.xDataAFEList.keys())
        self.opt_df['SwitchTmax'] = self.opt_df[['Igbt1Temp','Igbt2Temp','Igbt5Temp','Igbt7Temp']].max(axis=1)
        self.opt_df['DiodeTmax'] = self.opt_df[['D1Temp','D2Temp','D5Temp','D7Temp']].max(axis=1)
        self.plot_df['SwitchTmax'] = self.plot_df[['Igbt1Temp','Igbt2Temp','Igbt5Temp','Igbt7Temp']].max(axis=1)
        self.plot_df['DiodeTmax'] = self.plot_df[['D1Temp','D2Temp','D5Temp','D7Temp']].max(axis=1)
        self.scIgbtCombo.addItems(self.igbtList[plotTopology])
        self.scDiodeCombo.addItems(self.diodeList[plotTopology])
        self.scIgbtCombo.setCurrentIndex(-1) 
        self.scDiodeCombo.setCurrentIndex(-1)
        self.plotScRadio.setChecked(False)  
        self.plotLinRadio.setChecked(False)
        self.invTotalRadio.setChecked(False)
        self.invDiodeRadio.setChecked(False) 
        self.invIgbtRadio.setChecked(False) 
        self.opPointBox.setEnabled(False)  
        self.scatterDataBox.setEnabled(False)
        self.tempScaleBtn.setChecked(False)
        self.tempScaleBtn.setEnabled(False)
        self.plotBtn.setEnabled(False)
        self.xDatacomboBox.setCurrentIndex(-1)
        self.xDatacomboBox.setEnabled(False)
        self.MplWidget.canvas.mpl_disconnect(self.cid)
        self.MplWidget.canvas.figure.set_visible(False)
        self.OptimalChartArea.canvas.figure.set_visible(False)
        self.NPCTempHouse.setEnabled(False)
        self.B6TempHouse.setEnabled(False)
        self.TNPCTempHouse.setEnabled(False)
        self.ANPCTempHouse.setEnabled(False)
        self.MplWidget.toolbar.hide()
        self.OptimalChartArea.toolbar.hide()
        
    def resetControls(self):
        df_all = pd.read_pickle(self.invfilepath)
        self.plotInvBtn.setChecked(True)
        plotTopology = self.topologyCombo.currentText()
        self.plot_df =  df_all[(df_all['Topology']==plotTopology)& (df_all['Status']=='Ok')].copy()
        self.plot_df['SwitchTmax'] = self.plot_df[['Igbt1Temp','Igbt2Temp','Igbt5Temp','Igbt7Temp']].max(axis=1)
        self.plot_df['DiodeTmax'] = self.plot_df[['D1Temp','D2Temp','D5Temp','D7Temp']].max(axis=1)
        self.MplWidget.canvas.mpl_disconnect(self.cid)
        self.scIgbtCombo.clear()
        self.scDiodeCombo.clear()
        self.opComboType.clear()
        self.xDatacomboBox.clear()
        self.rePlotInfo={}
        self.tempScaleBtn.setChecked(False)
        self.tempScaleBtn.setEnabled(False)
        self.scIgbtCombo.addItems(self.igbtList[plotTopology])
        self.scDiodeCombo.addItems(self.diodeList[plotTopology])
        self.filterList = deepcopy(self.xDataInvList['V_DC'])
        self.xDatacomboBox.addItems(self.xDataInvList.keys())
        self.opComboType.insertItems(0,self.filterList)
        self.scIgbtCombo.setCurrentIndex(-1) 
        self.scDiodeCombo.setCurrentIndex(-1)
        self.xDatacomboBox.setCurrentIndex(-1)
        self.xDatacomboBox.setEnabled(False)
        button = self.buttonGroupPlotType.checkedButton()
        if button :
            self.buttonGroupPlotType.setExclusive(False)
            button.setChecked(False)
            self.buttonGroupPlotType.setExclusive(True)
        button = self.buttonGroupScatterData.checkedButton()
        if button :
            self.buttonGroupScatterData.setExclusive(False)
            button.setChecked(False)
            self.buttonGroupScatterData.setExclusive(True)
        self.plotScRadio.setChecked(False)  
        self.plotLinRadio.setChecked(False)
        self.invTotalRadio.setChecked(False)
        self.invDiodeRadio.setChecked(False) 
        self.invIgbtRadio.setChecked(False) 
        self.opPointBox.setEnabled(False)  
        self.scatterDataBox.setEnabled(False)
        self.clear()
        self.MplWidget.canvas.figure.set_visible(False)
        self.MplWidget.toolbar.hide()
        
    def plotScatter(self,xData,yData,xLabel,yLabel,length):
        try :
            if len(list(xData.values())[0])==0:
                self.MplWidget.canvas.figure.set_visible(False)
                self.MplWidget.toolbar.hide()
                raise Exception('No simulations to plot')
            xMapList = []
            self.xList =  []
            self.MplWidget.canvas.axes.clear()
            self.c = np.random.randint(1,5,size=length)
            self.norm = plt.Normalize(1,4)
            self.cmap = plt.cm.RdYlGn
            self.xList = list(xData.values())[0]
            temp = defaultdict(lambda: len(temp))
            xMapList = [temp[ele] for ele in self.xList]
            self.sc['scatter'] = self.MplWidget.canvas.axes.scatter(xMapList, list(yData.values()),c=self.c, s=10, cmap=self.cmap, norm=self.norm)
            self.sc.pop('linear', None)
            self.MplWidget.canvas.axes.set_xlabel(xLabel)
            self.xList = list(Counter(self.xList).keys())
            xMapList = list(Counter(xMapList).keys())
            self.MplWidget.canvas.axes.set_xticks(xMapList)
            self.MplWidget.canvas.axes.set_xticklabels(self.xList)
            self.MplWidget.canvas.axes.set_ylabel(yLabel)
            self.annot = self.MplWidget.canvas.axes.annotate("", xy=(0,0), xytext=(15,15), va='top', textcoords="offset points",
                                bbox=dict(boxstyle="round", fc="w"),
                                arrowprops=dict(arrowstyle="->"))
            self.annot.set_visible(False)
            self.cid = self.MplWidget.canvas.mpl_connect('motion_notify_event', self.hover) 
            self.MplWidget.canvas.figure.set_visible(True)
            self.MplWidget.toolbar.show()
            self.MplWidget.canvas.draw()
        except Exception as e:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText(str(e.args[0]))
            msgBox.exec()
        
    def update_scatter_annot(self,sc,ind):
        xpos = None
        ypos = None
        pos = sc.get_offsets()[ind]
        self.annot.xy = pos 
        xpos= self.xList[int(pos[0])]
        ypos = float(pos[1])
        OpPoint = self.data2plot['Dataset'][(self.data2plot['Dataset'][[*self.data2plot['xData']][0]] == xpos) & (self.data2plot['Dataset'][[*self.data2plot['yData']][0]] == ypos)]

        text = "DS:{},\nV_DC :{},\nTLoss:{},\nLoad :{},\nPhi    :{},\nFsw   :{}".format("".join(str(OpPoint.iloc[0]['Datasheet'])),"".join(str(OpPoint.iloc[0]['V_DC'])),"".join(str(round(OpPoint.iloc[0]['ConvTotalLoss'],2))),
                                       "".join(str(OpPoint.iloc[0]['Load_S'])),"".join(str(OpPoint.iloc[0]['Load_phi'])),
                                       "".join(str(OpPoint.iloc[0]['f_s'])))
        self.annot.set_text(text)
        self.annot.get_bbox_patch().set_facecolor(self.cmap(self.norm(self.c[ind])))
        self.annot.get_bbox_patch().set_alpha(0.4)

    def update_linear_annot(self, line,idx) : 
        posx, posy = [line.get_xdata(orig=True)[idx], line.get_ydata()[idx]]
        self.annot.xy = (posx, posy)
        leg = line.axes.get_legend()
        ind = line.axes.get_lines().index(line)
        legendValue = leg.texts[ind].get_text()
        index = set(self.filterList)-self.filter.keys()
        key = self.filterList[2] if index == set() else index.pop()
        if self.linAnnotKeys[0] == 'Datasheet':
            xlabels = line.axes.get_xticklabels(True)
            xlabels = [item.get_text() for item in line.axes.get_xticklabels()]
            xlabels = list(filter(None, xlabels))
            text = f'{key} :{legendValue},\n{self.linAnnotKeys[0]} :{xlabels[posx]},\n{self.linAnnotKeys[1]} :{posy:.2f}'
        else:
            text = f'{key} :{legendValue},\n{self.linAnnotKeys[0]} :{posx:.2f},\n{self.linAnnotKeys[1]} :{posy:.2f}'
        self.annot.set_text(text)
        self.annot.get_bbox_patch().set_alpha(0.4)

    def hover(self,event):
        vis = self.annot.get_visible()
        (key,lines),*rest = self.sc.items()
        lines = lines if isinstance(lines, list) else [lines]
        if event.inaxes == self.MplWidget.canvas.axes:
            for plotLine in lines :
                cont, ind = plotLine.contains(event)
                if cont:
                    if key == 'linear':
                        self.update_linear_annot(plotLine, ind['ind'][0])
                    elif key == 'scatter':
                        self.update_scatter_annot(plotLine,ind['ind'][0])
                    self.annot.set_visible(True)
                    self.MplWidget.canvas.draw_idle()
                else:
                    if vis:
                        self.annot.set_visible(False)
                        self.MplWidget.canvas.draw_idle()
        

    def onChange(self, ord):
        if ord ==1:
            self.optRangeControls.hide()
            self.resize(970,525)
            self.plotControls.show()
        elif ord == 2:
            self.plotControls.hide()
            self.resize(1070,525)
            self.optRangeControls.show()  
        else :
            self.plotControls.hide()
            self.optRangeControls.hide()
            self.adjustSize()


    def checkThermalParams(self,df):
        def checkIfExists(sheetList):
            isthere = False
            for sheet in sheetList:
                isthere = ~isthere 
                isthere = isthere and sheet in df.index
            return isthere
        return checkIfExists

    def validatedInputs(self,inputValues):
        inputRange = {'DC Link':1200, 'Temp':150}
        invalidCollection = {}
        for input in inputValues:
           inValids = [x for x in inputValues[input] if x>=inputRange[input]]
           if len(inValids):
               invalidCollection.update({input:inValids})
        return invalidCollection

    def simulate(self):       
        try :
            inputs ={}
            self.statusWriteLabel.setStyleSheet("")
            self.statusWriteLabel.clear()
            dcVltgList = self.dcVltgIn.toPlainText()
            dcVltgList = re.split(',|\s+|;|\n',dcVltgList)
            dcVltgListNew = [int(i) for i in dcVltgList]
            loadWInList = self.loadWIn.toPlainText()
            loadWInList = re.split(',|\s+|;|\n',loadWInList)
            loadWInListNew = [float(i) for i in loadWInList]
            pfDegreeInList = self.pfDegreeIn.toPlainText()
            pfDegreeInList = re.split(',|\s+|;|\n',pfDegreeInList)
            pfDegreeInListNew = [float(i) for i in pfDegreeInList]
            switchFreqInList = self.switchFreqIn.toPlainText()
            switchFreqInList = re.split(',|\s+|;|\n',switchFreqInList)
            switchFreqInListNew = [int(i) for i in switchFreqInList]
            tempInList = self.tempIn.toPlainText()
            tempInList = re.split(',|\s+|;|\n',tempInList)
            tempInListNew = [int(i) for i in tempInList]
            fOutList = self.fOutIn.toPlainText()
            fOutList = re.split(',|\s+|;|\n',fOutList)
            fOutListNew = [int(i) for i in fOutList]
            dataSheets = self.dataSheetComboBox.checkedItems()
            inputs = {'DC Link':dcVltgListNew,'Temp':tempInListNew}
            invalids = self.validatedInputs(inputs)
            if len(invalids):
                raise InvalidInputs(invalids)
            if dataSheets == []:
                raise Exception('Please select atleast one Datasheet!\n(Hint : Check should appear)')
            paramsContainer = {'V_DC':dcVltgListNew,'Load_S':loadWInListNew,'Load_phi':pfDegreeInListNew,'Mains_S':loadWInListNew,'Mains_phi':pfDegreeInListNew,'f_s':switchFreqInListNew,'f_out':fOutListNew,
                               'T_HS':tempInListNew,'dataSheets':dataSheets}
            for x in paramsContainer:
                print(x + ' = '+ str(paramsContainer[x])+':Accepted')
            self.statusWriteLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
            self.statusWriteLabel.setText('Inputs are good')
            if os.path.exists(self.Tfilepath) :
                df = pd.read_csv(self.Tfilepath,index_col =['Datasheet'])
                checkIf = self.checkThermalParams(df)
                totalSheets = self.loadThermalBox(True)
                if not checkIf(totalSheets):
                    raise Exception('Check the Thermal Params')
            else :
                raise Exception('Thermal params file not found')
            self.statusWriteLabel.adjustSize()
            saveData = self.saveLossData.isChecked()
            isAFEselected = self.AFEModeBtn.isChecked()
            topology = self.buttonGroupTopology.checkedButton().text()
            createobj = startConnection(paramsContainer,saveData,isAFEselected, topology)
            createobj.gismsUpdate.connect(self.updateGSIMS)
            createobj.progressUpdate.connect(self.updateProgressBar)
            createobj.tabsDFUpdate.connect(self.updateTabsDF)
            self.progressBar.show()
            self.progressBar.setValue(1)
            self.progressBar.setMaximum(100)
            test_thread = threading.Thread(target = createobj.initiateConnection)
            test_thread.start()
        except ValueError:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText("Please check the inputs provided")
            msgBox.exec()
        except InvalidInputs as e:
            invalids = e.args[0]
            errorString = ''
            for invalid in invalids:
                errorString =  errorString+ "{} = {} invalid\n".format(''.join(invalid),''.join(str(invalids[invalid])))
            self.statusWriteLabel.setStyleSheet("QLabel { background-color : red; color : blue; }")
            self.statusWriteLabel.setText(errorString)
            self.statusWriteLabel.adjustSize()
        except Exception as e:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText(str(e.args[0]))
            msgBox.exec()
        except :
            errorOutput = 'unexpected error : '+ str( sys.exc_info()[0])
            print(errorOutput)
            self.statusWriteLabel.setStyleSheet("QLabel { background-color : red; color : blue; }")
            self.statusWriteLabel.setText('Please check the inputs provided\n'+ str( sys.exc_info()[0]))
            self.statusWriteLabel.adjustSize()
   

    def showGSIMSData(self):
        if(self.showGSIMS.isChecked()):
            self.gridLayoutWidget.show()
            self.topologyPicture.hide()
        else:
            self.gridLayoutWidget.hide()
            self.topologyPicture.show()
    
            
    @QtCore.pyqtSlot(dict)
    def updateGSIMS(self,out):
        if out :
            self.invCosPhiOut.setText(str(round(out['cos_phi_inv'],3)))
            self.modulationOut.setText(str(round(out['m'],3)))
            self.peakRlcCurrentOut.setText(str(round(out['I_Peak_inv'],2)))
            self.cCurrentOut.setText(str(round(out['I_Filter_C'],2)))
            self.lVltgOut.setText(str(round(out['U_Filter_L'],2)))
            self.invVtlgOut.setText(str(round(out['U_RMS_inv'],2)))
            if self.AFEModeBtn.isChecked():
                self.loadVltgOut.setText(str(round(out['U_Mains_LL'],2)))
                self.loadZOut.setText(str(complex(round(out['Z_Inv'].real,2),round(out['Z_Inv'].imag,2))))
            else :
                self.loadVltgOut.setText(str(round(out['U_Load_LL'],2)))
                self.loadZOut.setText(str(complex(round(out['Z_Load'].real,2),round(out['Z_Load'].imag,2))))
        else :
            self.invCosPhiOut.setText('')
            self.modulationOut.setText('')
            self.peakRlcCurrentOut.setText('')
            self.cCurrentOut.setText('')
            self.lVltgOut.setText('')
            self.invVtlgOut.setText('')
            self.loadVltgOut.setText('')
            self.loadZOut.setText('')
            
    @QtCore.pyqtSlot(str)
    def updateTabsDF(self,mode) :  
        if not (self.tabWidget.isTabEnabled(1) or self.tabWidget.isTabEnabled(2)):
            self.tabWidget.setTabEnabled(1,True)
            self.tabWidget.setTabEnabled(2,True)
            self.initializeTabControls(mode) 
        optModeBtn =  self.buttonGroupOptMode.checkedButton()
        plotModeBtn = self.buttonGroupPlotMode.checkedButton()
        self.optChangeDb(optModeBtn,True)
        self.plotChangeDb(plotModeBtn, True)
        if self.tabWidget.currentIndex() == 1 or self.tabWidget.currentIndex() == 2:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText("Database updated! Consider replotting")
            msgBox.exec()

    @QtCore.pyqtSlot(int,str)
    def updateProgressBar(self,value,text) :
        if value==-1:
            self.progressBar.setFormat(text)
        else :
            self.progressBar.setValue(value)
            self.progressBar.setFormat(text +": %v")
    

    def openDataBase(self):
        if self.dataBaseWindow is None:
            self.dataBaseWindow = dataBaseClass()
            palette = getPalette() if self.themeFlag else QtGui.QPalette()
            self.dataBaseWindow.setPalette(palette)
        self.dataBaseWindow.show()
         

    def loadPrevParams(self, filepath, checkedMode):
        df = pd.read_pickle(filepath)
        df = df[df['Status']=='Ok']
        if not df.empty:
            lastSweepParams = df.iloc[-1]
            self.dcVltgIn.setPlainText(str(lastSweepParams['V_DC']))
            if checkedMode == 'AFE':
                self.loadWIn.setPlainText(str(lastSweepParams['Mains_S']))
                self.pfDegreeIn.setPlainText(str(lastSweepParams['Mains_phi']))
            elif checkedMode == 'Inverter':
                self.loadWIn.setPlainText(str(lastSweepParams['Load_S']))
                self.pfDegreeIn.setPlainText(str(lastSweepParams['Load_phi']))
            self.switchFreqIn.setPlainText(str(lastSweepParams['f_s']))
            self.tempIn.setPlainText(str(lastSweepParams['T_HS']))
            self.fOutIn.setPlainText(str(lastSweepParams['f_out']))
        else :
            self.dcVltgIn.clear()
            self.loadWIn.clear()
            self.pfDegreeIn.clear()
            self.switchFreqIn.clear()
            self.tempIn.clear()
            self.fOutIn.clear()
   
    def loadThermalBox(self,isInnerCall):
        try :
            datasheets = []
            selectedSheets = self.dataSheetComboBox.checkedItems()
            if not selectedSheets :
                raise Exception('Select atleast one Datasheet!')
            df = pd.read_csv(self.datasheetpath)
            topology = self.buttonGroupTopology.checkedButton().text()
            for datasheet in selectedSheets:
                datasheets = datasheets+df[(df['Topology'] == topology)&(df['Datasheet']==datasheet)][['T1','T2','T3','T4','D1','D2','D3','D4','D5','D6']].values.tolist()
            datasheets = list(itertools.chain.from_iterable(datasheets))
            array = np.array(datasheets)
            array = array[array!='nan']
            datasheets = np.unique(array).tolist()
            if not isInnerCall:
                self.thermalWindow = thermalParamClass(datasheets)  #always expects non emtpy datasheets else is [] is given then unchecked error type returns
                palette = getPalette() if self.themeFlag else QtGui.QPalette()
                self.thermalWindow.setPalette(palette)
                self.thermalWindow.show()
            else :
                return datasheets
        except Exception as e:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText(str(e.args[0]))
            msgBox.exec()

#A custom defined exception to validate inputs and differentiate from base Exception
class InvalidInputs(Exception):
    pass

def getSelectionKey(findKey):
    TempKeys = {'Igbt1Temp':['IG1','IG4'],'Igbt2Temp':['IG2','IG3'],'Igbt5Temp':['IG5','IG6'],'Igbt7Temp' : ['IG7','IG8'],'SwitchTmax':['ConvTotalLoss'],
                'D1Temp':['D1','D4'],'D2Temp':['D2','D3'],'D5Temp':['D5','D6'],'D7Temp' : ['D7','D8'],'DiodeTmax':['ConvTotalLoss']}
    listOfKeys = list()
    listOfItems = TempKeys.items()
    for item in listOfItems:
        for TempValue in item[1]:
            if TempValue == findKey:
                listOfKeys.append(item[0])
    return listOfKeys   
def getXisLabel(x):
    return {
        'V_DC': 'Dc Link Voltage',
        'f_s': 'Switching Frequency',
        'Load_phi': 'Load power factor(in deg)',
        'Load_S': 'Apparent Load Power(in W)',
        'Mains_phi': 'Mains power factor(in deg)',
        'Mains_S': 'Apparent Mains Power(in W)',
        'ConvTotalLoss' : 'Total Losses(in W)',
        'Datasheet':'Datasheet',
    }.get(x, x+' Loss(in W)')   

def getYisLabel(y):
    return {
        'Igbt1Temp' : 'IG1/IG4 Junction Temp (°C)',
        'Igbt2Temp' : 'IG2/IG3 Junction Temp (°C)',
        'Igbt5Temp' : 'IG5/IG6 Junction Temp (°C)',
        'Igbt7Temp' : 'IG7/IG8 Junction Temp (°C)',
        'D1Temp' : 'D1/D4 Junction Temp (°C)',
        'D2Temp' : 'D2/D3 Junction Temp (°C)',
        'D5Temp' : 'D5/D6 Junction Temp (°C)',
        'D7Temp' : 'D7/D8 Junction Temp (°C)',
        'SwitchTmax' : 'Max Switch/Diode Temp (°C)',
        'DiodeTmax' : 'Max Switch/Diode Temp (°C)'
        }.get(y,getXisLabel(y))
def getPalette():
    palette = QtGui.QPalette()
    palette.setColor(QtGui.QPalette.Window, QtGui.QColor(53,53,53))
    palette.setColor(QtGui.QPalette.WindowText, QtCore.Qt.white)
    palette.setColor(QtGui.QPalette.Base, QtGui.QColor(15,15,15))
    palette.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(53,53,53))
    palette.setColor(QtGui.QPalette.ToolTipBase, QtCore.Qt.white)
    palette.setColor(QtGui.QPalette.ToolTipText, QtCore.Qt.white)
    palette.setColor(QtGui.QPalette.Text, QtCore.Qt.white)
    palette.setColor(QtGui.QPalette.Button, QtGui.QColor(53,53,53))
    palette.setColor(QtGui.QPalette.ButtonText, QtCore.Qt.white)
    palette.setColor(QtGui.QPalette.BrightText, QtCore.Qt.red)
    palette.setColor(QtGui.QPalette.Highlight, QtGui.QColor(142,45,197).lighter())
    palette.setColor(QtGui.QPalette.HighlightedText, QtCore.Qt.black) 
    return palette

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    mainWindow = MainWindow()
    mainWindow.show()
    try:
        sys.exit(app.exec_())
    except SystemExit:
        print('Closing Window....')

