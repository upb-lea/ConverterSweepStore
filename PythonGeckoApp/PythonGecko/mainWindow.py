# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'initializeWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import sys
import threading
from PyQt5.QtWidgets import QApplication,QWidget,QMainWindow,QMessageBox,QAbstractButton
from  matplotlib.backends.backend_qt5agg  import  ( NavigationToolbar2QT  as  NavigationToolbar )
import matplotlib.pyplot as plt
import matplotlib as mpl
import  random
import math
import itertools
from PyQt5 import QtCore,uic
from PyQt5.QtGui import QIcon, QPixmap
from pandasModel import pandasModel
from thermalParamClass import thermalParamClass
from checkablecombobox import CheckableComboBox
import pyqtgraph as pg
import functools
import re
import os
import numpy as np
import time as t
import csv
import pandas as pd
from retrying import retry
from GISMSParameters_phi import GISMSParameters_phi
import glob
import psweep as ps
import subprocess
#from pandasgui import show
from startConnection import startConnection 
from dataBaseClass import dataBaseClass
opLabelAppend = ''
class MainWindow(QMainWindow):
    invfilepath = r'calc\results.pk'
    afefilepath = r'calc_AFE\results.pk'
    Tfilepath = r'calc\Thermal\params.csv'
    datasheetpath = r'calc\Thermal\DatasheetDB.csv'
    ## Make all plots clickable
    clickedPen = pg.mkPen('b', width=2)
    igbtList = {'B6':['IG1','IG2'],'NPC':['IG1','IG2','IG3','IG4'],'TNPC':['IG1','IG2','IG3','IG4'],'FC-ANPC':['IG1','IG2','IG3','IG4','IG5','IG6','IG7','IG8']}
    diodeList = {'B6':['D1','D2'],'NPC':['D1','D2','D3','D4','D5','D6'],'TNPC':['D1','D2','D3','D4'],'FC-ANPC':['D1','D2','D3','D4','D5','D6','D7','D8']}
    xDataInvList = {'V_DC':['Load_S','f_s','Load_phi'],'Load_S':['V_DC','f_s','Load_phi'],'f_s':['V_DC','Load_S','Load_phi'],'Load_phi':['V_DC','Load_S','f_s']}
    xDataAFEList = {'V_DC':['Mains_S','f_s','Mains_phi'],'Mains_S':['V_DC','f_s','Mains_phi'],'f_s':['V_DC','Mains_S','Mains_phi'],'Mains_phi':['V_DC','Mains_S','f_s']}
    filterListOld = {'Inverter':['Load_S','f_s','Load_phi'],'AFE':['Mains_S','f_s','Mains_phi']}
    filterList = []
    topologyList = ['B6','NPC','TNPC','FC-ANPC']        
    lastClicked = []
    linAnnotKeys = []
    data2plot ={}
    filter = {}
    rePlotInfo = {}
    def __init__(self,parent =None): 
        super(MainWindow,self).__init__(parent)
        uic.loadUi('initializeWindow.ui',self)
        _translate = QtCore.QCoreApplication.translate
        self.setWindowIcon(QIcon('clienticon.png'))
        self.setWindowTitle(_translate("MainWindow", "Converter Sweep Store"))
        app.aboutToQuit.connect(self.closeEvent)
        self.simulateBtn.clicked.connect(self.simulate)
        self.dataBaseWindow = None
        self.showGSIMS.stateChanged.connect(self.showGSIMSData)
        self.tabWidget.currentChanged.connect(self.onChange)
        self.progressBar.hide()
        self.progressBar.reset()
        self.databaseBtn.clicked.connect(self.openDataBase) 
        self.pandasGUIBtn.clicked.connect(self.openPandasGUI)
        self.toolButtonThermal.clicked.connect(self.loadThermalBox)
        self.toolButtonThermal.setAutoRaise(True)
        self.plotControls.hide()
        self.optRangeControls.hide()
        self.cid = self.MplWidget.canvas.mpl_connect('motion_notify_event', self.hover) 
        self.buttonGroupScatterData.setId(self.invTotalRadio,1)
        self.buttonGroupScatterData.setId(self.invIgbtRadio,2)
        self.buttonGroupScatterData.setId(self.invDiodeRadio,3)
        self.buttonGroupRangeType.setId(self.optPinToolBtn,1)
        self.buttonGroupRangeType.setId(self.optVdcToolBtn,2)
        self.buttonGroupRangeType.setId(self.optSwToolBtn,3)
        self.buttonGroupRangeType.buttonClicked[int].connect(self.rangeAndUpdate)
        self.scDiodeCombo.textActivated.connect(self.scComboboxChanged)
        self.scIgbtCombo.textActivated.connect(self.scComboboxChanged)
        self.opComboType.textActivated.connect(self.updateOpBtnLabel)
        self.buttonGroupTopology.buttonClicked.connect(self.loadDataSheets)
        self.buttonGroupPlotType.buttonClicked.connect(self.selectPlotType)
        self.buttonGroupScatterData.buttonClicked.connect(self.updateScatterRadios)
        self.buttonGroupMode.buttonClicked.connect(self.updateAfeLabels)
        self.opAddBtn.clicked.connect(self.addFilterCriteria)
        self.plotBtn.clicked.connect(self.validateFilter)
        self.optInvBtn.setChecked(True)
        self.plotInvBtn.setChecked(True)
        self.InverterModeBtn.setChecked(True)
        self.buttonGroupPlotMode.buttonClicked.connect(self.plotChangeDb)
        self.buttonGroupOptMode.buttonClicked.connect(self.optChangeDb)
        self.opClearBtn.clicked.connect(self.clear)
        self.searchOptBtn.clicked.connect(self.findOptimum)
        self.topologyCombo.insertItems(0,self.topologyList)
        self.topologyCombo.textActivated.connect(self.resetControls)
        #self.xDatacomboBox.insertItems(0, self.xDataList.keys())
        self.xDatacomboBox.textActivated.connect(self.replotScatter)
        self.sc = {}
        self.PinRangeSelector.hide()
        self.VdcRangeSelector.hide()
        self.SwRangeSelector.hide()
        self.gridLayoutWidget.hide()
        self.VdcRangeSelector.setBackgroundStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #222, stop:1 #333);')
        self.VdcRangeSelector.setSpanStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #282, stop:1 #393);')
        self.VdcRangeSelector.setStyleSheet("""
        QRangeSlider > QSplitter::handle {
            background: #777;
            border: 1px solid #555;
        }
        QRangeSlider > QSplitter::handle:vertical {
            height: 2px;
        }
        QRangeSlider > QSplitter::handle:pressed {
            background: #ca5;
        }
        """)
        self.PinRangeSelector.setBackgroundStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #222, stop:1 #333);')
        self.PinRangeSelector.setSpanStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #282, stop:1 #393);')
        self.PinRangeSelector.setStyleSheet("""
        QRangeSlider > QSplitter::handle {
            background: #777;
            border: 1px solid #555;
        }
        QRangeSlider > QSplitter::handle:vertical {
            height: 2px;
        }
        QRangeSlider > QSplitter::handle:pressed {
            background: #ca5;
        }
        """)
        self.SwRangeSelector.setBackgroundStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #222, stop:1 #333);')
        self.SwRangeSelector.setSpanStyle('background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #282, stop:1 #393);')
        self.SwRangeSelector.setStyleSheet("""
        QRangeSlider > QSplitter::handle {
            background: #777;
            border: 1px solid #555;
        }
        QRangeSlider > QSplitter::handle:vertical {
            height: 2px;
        }
        QRangeSlider > QSplitter::handle:pressed {
            background: #ca5;
        }
        """)
        self.checkDatabase()
        self.loadDataSheets()
        timer = QtCore.QTimer(self, interval=1000, timeout=self.showTime)
        timer.start()
        self.showTime()

    def closeEvent(self,val) :
        sys.exit(0)

    def checkDatabase(self):
        mode =''
        fileInv = os.path.exists(self.invfilepath)
        fileAfe = os.path.exists(self.afefilepath)
        if not (fileInv and fileAfe):
            IGBTColumnList = ['IG1_con','IG1_sw','IG2_con','IG2_sw','IG3_con','IG3_sw','IG4_con','IG4_sw','IG5_con','IG5_sw','IG6_con','IG6_sw','IG7_con','IG7_sw','IG8_con','IG8_sw']
            DiodeColumnList = ['D1_con','D1_sw','D2_con','D2_sw','D3_con','D3_sw','D4_con','D4_sw','D5_con','D5_sw','D6_con','D6_sw','D7_con','D7_sw','D8_con','D8_sw']
            TotalColumnList = ['file','InvTotalLoss','IG1','IG2','IG3','IG4','IG5','IG6','IG7','IG8','D1','D2','D3','D4','D5','D6','D7','D8']
            TempColumnList = ['Igbt1Temp','Igbt2Temp','Igbt5Temp','Igbt7Temp','D1Temp','D2Temp','D5Temp','D7Temp']  
            if not fileInv:
                InvOperatingList = ['Topology','Datasheet','V_DC','Load_S','Load_phi','f_s','T_HS','f_out','_run_id','_pset_id','_calc_dir','_time_utc','TransformerLoss']#13
                columns_list = InvOperatingList+TotalColumnList+TempColumnList+IGBTColumnList+DiodeColumnList
                df = pd.DataFrame(columns=columns_list)
                df.to_pickle(self.invfilepath)
            if not fileAfe :
                AfeOperatingList = ['Topology','Datasheet','V_DC','Mains_S','Mains_phi','f_s','T_HS','f_out','_run_id','_pset_id','_calc_dir','_time_utc','TransformerLoss']
                columns_list = AfeOperatingList+TotalColumnList+TempColumnList+IGBTColumnList+DiodeColumnList
                df = pd.DataFrame(columns=columns_list)
                df.to_pickle(self.afefilepath)
        df_inv = pd.read_pickle(self.invfilepath)
        df_afe = pd.read_pickle(self.afefilepath)
        if (df_inv.empty and df_afe.empty) :
            self.tabWidget.setTabEnabled(1, False)
            self.tabWidget.setTabEnabled(2, False)
        elif(not df_inv.empty) :
            mode = 'Inverter'
            self.InverterModeBtn.setChecked(True)
            self.loadPrevParams(self.invfilepath,mode)
            self.initializeTabControls(mode)
        elif(not df_afe.empty):
            mode = 'AFE'
            self.AFEModeBtn.setChecked(True)
            self.loadPrevParams(self.afefilepath, mode)
            self.initializeTabControls(mode)

    def loadDataSheets(self):
        topology = self.buttonGroupTopology.checkedButton().text()
        pixmap = QPixmap(topology+'.png')
        self.topologyPicture.setPixmap(pixmap)
        self.topologyPicture.setScaledContents(True)
        self.dataSheetComboBox.clear()
        df = pd.read_csv(self.datasheetpath)
        datasheets = df[df['Topology'] == topology]['Datasheet'].tolist()
        self.dataSheetComboBox.insertItems(0,datasheets)
   
    def openPandasGUI(self) :
        df = pd.read_pickle(self.invfilepath)
        #show(df)

    def conjunction(*conditions):
        return functools.reduce(np.logical_and, conditions)

    def clear(self):
        self.filter = {}
        self.opSelectDisplayLabel.clear()
        self.opAddBtn.setText('Add')
        self.opErrorLabel.setStyleSheet("")
        self.opErrorLabel.clear()
    
    def updateAfeLabels(self,button):
        if button.text()=='AFE':
            self.loadWLabel.setText("Mains in VA       :")
            self.loadVltg.setText("Mains Voltage       :")
            self.loadZ.setText("Load Inv(Z_inv) :")
            self.loadPrevParams(self.afefilepath,'AFE')
            self.updateGSIMS(False)
        else :
            self.loadWLabel.setText("Load in VA        :")
            self.loadVltg.setText("Load Voltage       :")
            self.loadZ.setText("Load Imp(Z_L)  :")
            self.loadPrevParams(self.invfilepath,'Inverter')
            self.updateGSIMS(False)

    def plotChangeDb(self,button):
        plotTopology = self.topologyCombo.currentText()
        plotMode = button.text()
        if plotMode =='AFE':
           df_all = pd.read_pickle(self.afefilepath)
           self.xDatacomboBox.clear()
           self.xDatacomboBox.addItems(self.xDataAFEList.keys())
        elif plotMode == 'Inverter':
           df_all = pd.read_pickle(self.invfilepath)
           self.xDatacomboBox.clear()
           self.xDatacomboBox.addItems(self.xDataInvList.keys())
        self.plot_df = df_all[df_all['Topology']==plotTopology]
        self.xAxisChanged('V_DC')
        self.replotScatter()

    def replotScatter(self):
        self.clear()
        if len(self.rePlotInfo) == 3 and self.rePlotInfo['plotType'] == 'Scatter':
          self.updateScatterRadios(self.rePlotInfo['LossTypeBtn'])
        
    def xAxisChanged(self,xAxisLabel=None):
        self.clear()
        plotMode = self.buttonGroupPlotMode.checkedButton().text()
        self.filterList.clear()
        if plotMode == 'Inverter':
            self.filterList = self.xDataInvList[xAxisLabel][:]
        elif plotMode == 'AFE':
            self.filterList = self.xDataAFEList[xAxisLabel][:]
        self.filter.clear()
        self.opComboType.clear()
        self.opComboType.insertItems(0,self.filterList)

    def optChangeDb(self,button):
        self.optStatusLabel.setStyleSheet("")  #check the position
        self.optStatusLabel.clear()
        optMode = button.text()
        self.opt_df = pd.DataFrame(None)
        if optMode =='AFE':
            self.opt_df = pd.read_pickle(self.afefilepath)
            self.opt_df['PWatts'] = round(self.opt_df['Mains_S']* self.opt_df['Mains_phi'].apply(math.cos))
        else:
            self.opt_df = pd.read_pickle(self.invfilepath)
            self.opt_df['PWatts'] = round(self.opt_df['Load_S']* self.opt_df['Load_phi'].apply(math.cos))
        self.OptimalChartArea.canvas.figure.set_visible(False)
        self.OptimalChartArea.toolbar.hide()
        self.OptimalChartArea.canvas.draw()
        self.rangeAndUpdate() #UPDATES all sliders irrespective of visibility of each slider everytime db gets changed
        

    def updateOpBtnLabel(self):
        key = self.opComboType.currentText()
        if key in self.filter:
            self.opAddBtn.setText('Update')
        else:
            self.opAddBtn.setText('Add')

    @QtCore.pyqtSlot()
    def showTime(self):
        CurrTime = QtCore.QTime.currentTime()
        text = CurrTime.toString("HH mm ss" if CurrTime.second() % 2 == 0 else "HH:mm:ss")
        self.lcdDateTime.display(text)

    def rangeAndUpdate(self,id=None): 
        if not self.opt_df.empty:
            vdcMinReq =  185
            vdcMaxReq = 260
            vdcNominal = 216
            fsMaxReq = 14400
            fsMinReq = 7200
            fsNominal = 10800
            pWNomial = 32000
            def findRange(Min,Max,MinReq,MaxReq):
                if(MinReq > Min):
                    Min = MinReq
                if(MaxReq < Max):
                    Max = MaxReq
                return Max,Min
            vDcMax = self.opt_df['V_DC'].max()
            vDcMin = self.opt_df['V_DC'].min()
            fsMax = self.opt_df['f_s'].max()    
            fsMin = self.opt_df['f_s'].min()
            pWMax = self.opt_df['PWatts'].max()
            pWMin = self.opt_df['PWatts'].min()
            setVDcMax,setVDcMin = findRange(vDcMin,vDcMax,vdcMinReq,vdcMaxReq)
            setFsMax,setFsMin = findRange(fsMin,fsMax,fsMinReq,fsMaxReq)
            setPWMax,setPWMin = findRange(pWMin,pWMax,10000,pWNomial)
            btnOptions = { 1:{'rangeBtn':self.PinRangeSelector,'inputBtn':self.optPinInput,'Max':pWMax,'Min':pWMin,'rangeMin':setPWMin,'rangeMax':setPWMax,'normValue':1000,'decimalValue':1},
                           2:{'rangeBtn':self.VdcRangeSelector,'inputBtn':self.optVdcInput,'Max':vDcMax,'Min':vDcMin,'rangeMin':setVDcMin,'rangeMax':setVDcMax},
                           3:{'rangeBtn':self.SwRangeSelector,'inputBtn':self.optSwInput,'Max':fsMax,'Min':fsMin,'rangeMin':setFsMin,'rangeMax':setFsMax,'normValue':1000,'decimalValue':1}
                          }
            if id is None :
                for slider in btnOptions:
                    self.updateSlider(**btnOptions[slider])
            else :
                self.toggleInput(**btnOptions[id])
            self.searchOptBtn.setEnabled(True)
        else:
            self.searchOptBtn.setEnabled(False)
            self.PinRangeSelector.hide()
            self.VdcRangeSelector.hide()
            self.SwRangeSelector.hide()
            self.optPinInput.clear()
            self.optPinInput.show()
            self.optVdcInput.clear()
            self.optVdcInput.show()
            self.optSwInput.clear()
            self.optSwInput.show()
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText('Database is Empty!')
            msgBox.exec() 
   
    def findOptimum(self):
        searchSeries = {}
        plotDFCollection = {}
        refinedDFs = {}
        searchValue = []
        errorMsg = ''
        self.optStatusLabel.setStyleSheet("")  #check the position
        self.optStatusLabel.clear()
        self.OptimalChartArea.canvas.figure.clf()
        self.OptimalChartArea.canvas.draw_idle()
        if not 'PWatts' in self.opt_df.columns:
            if self.buttonGroupOptMode.checkedButton().text() == 'AFE':
                self.opt_df['PWatts'] = round(self.opt_df['Mains_S']* self.opt_df['Mains_phi'].apply(math.cos))
            else :
                self.opt_df['PWatts'] = round(self.opt_df['Load_S']* self.opt_df['Load_phi'].apply(math.cos))
        def searchOptBtn(topology, rangeBtn,column, df,buttonInput,normalizeValue =1):
            if rangeBtn.isVisible(): 
                range = rangeBtn.getRange()
                actual_range = tuple([normalizeValue*x for x in range])
                searchValue = list(actual_range)
                filterSeries = df[column].between(*actual_range)
            else:
                searchValue = float(buttonInput.text())
                filterSeries = df[column]==searchValue
            isAValidSeries = filterSeries.sum()                                
            if not isAValidSeries:
                raise Exception("{} :{} = {} not found\n".format(''.join(topology),''.join(column),''.join(str(searchValue))))
            else : 
                return filterSeries
       
        for topology in self.topologyList:
            try :
                topology_df = self.opt_df[self.opt_df['Topology']== topology]
                searchSeries['pSearchSeries'] = searchOptBtn(topology,self.PinRangeSelector,'PWatts',topology_df, self.optPinInput,1000)
                searchSeries['vDcSearchSeries'] = searchOptBtn(topology,self.VdcRangeSelector,'V_DC',topology_df,self.optVdcInput)
                searchSeries['sWSearchSeries'] = searchOptBtn(topology,self.SwRangeSelector,'f_s',topology_df,self.optSwInput,1000)
            except ValueError:
                self.optStatusLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
                self.optStatusLabel.setText("Please check the inputs provided")
                self.optStatusLabel.adjustSize()
                break
            except Exception as e:
                errorMsg = errorMsg + str(e.args[0])
                self.optStatusLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
                self.optStatusLabel.setText(errorMsg)
                self.optStatusLabel.adjustSize()
                print(str(e.args[0]))
            else :
                seriesBoolReturns = list(searchSeries.values())
                plotDFCollection[topology] = topology_df[self.conjunction(*seriesBoolReturns)]
        if len(plotDFCollection) >0:
            refinedDFs =  plotDFCollection
            for topology in list(plotDFCollection):  #to avoid runtime error 
                try :
                    if refinedDFs[topology].empty :
                        del refinedDFs[topology]
                        raise Exception(topology+": Range not in DBase \n")
                except Exception as e:   
                    errorMsg = errorMsg + str(e.args[0])
                    self.optStatusLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
                    self.optStatusLabel.setText(errorMsg)
                    self.optStatusLabel.adjustSize()
        if len(refinedDFs) >0:
            self.processAndMaptoFigure(refinedDFs)
            

    def processAndMaptoFigure(self,dfsCollected):
        dfToBar = {}
        opPoint = {}
        for topology in dfsCollected:
            df = dfsCollected[topology]
            finalRow = df[df['InvTotalLoss']==df['InvTotalLoss'].min()].to_dict('records')[0]
            opPoint[topology] = finalRow
            if topology == 'NPC':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con'],finalRow['D5_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw'],finalRow['D5_sw']]
                index  = ['T1/T4','D1/D4','T2/T3','D2/D3','D5/D6']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
            elif topology == 'TNPC':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw']]
                index  = ['T1/T4','D1/D4','T2/T3','D2/D3']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
            elif topology == 'B6':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG2_con'],finalRow['D2_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG2_sw'],finalRow['D2_sw']]
                index  = ['T1','D1','T2','D2']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
            elif topology == 'FC-ANPC':
                conductionLoss = [finalRow['IG1_con'],finalRow['D1_con'],finalRow['IG6_con'],finalRow['D6_con'],finalRow['IG8_con'],finalRow['D8_con']]
                switchLoss = [finalRow['IG1_sw'],finalRow['D1_sw'],finalRow['IG6_sw'],finalRow['D6_sw'],finalRow['IG8_sw'],finalRow['D8_sw']]
                index  = ['T1/T4','D1/D4','T6','D6','T8','D8']
                dfToBar[topology] = pd.DataFrame({'Cond Loss': conductionLoss,'SW Loss': switchLoss}, index=index)
        plotNum = len(dfToBar)
        if plotNum == 1:
           self.OptimalChartArea.plotOne(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText('Only '+ str(list(dfToBar.keys())[0]) + ' exists in Range')
        if plotNum == 2:
           self.OptimalChartArea.plotTwo(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText('Only '+ list(dfToBar.keys())[0]+', '+list(dfToBar.keys())[1] + ' exists in Range')
        if plotNum == 3:
           self.OptimalChartArea.plotThree(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText(str(list(dfToBar.keys())[0])+', '+ list(dfToBar.keys())[1]+', '+list(dfToBar.keys())[2]  + ' exists in Range')
        if plotNum == 4:
           self.OptimalChartArea.plotFour(dfToBar,opPoint)
           self.optStatusLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
           self.optStatusLabel.setText(str(list(dfToBar.keys())[0])+', '+ list(dfToBar.keys())[1]+', '+list(dfToBar.keys())[2] +', '+list(dfToBar.keys())[3] + ' exists in Range')
        

    def toggleInput(self,rangeBtn,inputBtn,Max,Min,rangeMin,rangeMax,normValue=1,decimalValue=0):
            if rangeBtn.isVisible():
                rangeBtn.hide()
                inputBtn.show()
            else :
                inputBtn.hide() 
                rangeBtn.show()
                self.updateSlider(rangeBtn,inputBtn,Max,Min,rangeMin,rangeMax,normValue,decimalValue)
                   

    def updateSlider(self,rangeBtn,inputBtn,Max,Min,rangeMin,rangeMax,normValue= 1,decimalValue = 0):
                if Max == Min:
                    inputBtn.show()
                    inputBtn.setText(str(Max))
                    rangeBtn.hide()
                    return
                rangeBtn.setMin(round(Min/normValue,decimalValue))
                rangeBtn.setMax(round(Max/normValue,decimalValue))
                rangeBtn.setRange(round(rangeMin/normValue,decimalValue),round(rangeMax/normValue,decimalValue))
                
    def validateFilter(self) :
        try :
            selected = self.rePlotInfo['LossType']
        except KeyError:
            selected = None
            pass
        try :
            filtString = {}
            if not selected:
                raise Exception("select the loss type")
            if len(self.filter) < 2 :
                raise Exception("min 2 filters required")
            elif len(self.filter) == 2 or len(self.filter) == 3:
                for key in self.filter :
                   filtString[key] =  (self.plot_df[key] == self.filter[key])
                   if not filtString[key].values.sum():
                        raise Exception("{} = {} not found".format(''.join(key),''.join(str(self.filter[key]))))
            conditionsBoolReturns = list(filtString.values())
            resultDF = self.plot_df[self.conjunction(*conditionsBoolReturns)]
            if resultDF.empty :
                raise Exception("Not in DBase")
            index = set(self.filterList)- self.filter.keys()
            key =  self.filterList[2] if index == set() else index.pop()
            xLabel = self.xDatacomboBox.currentText()
            self.makeLinearPlot(resultDF, selected, xLabel, key)
        except Exception as e:
            self.opErrorLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
            self.opErrorLabel.setText(str(e.args[0]))


    def selectPlotType(self,button) :
        self.scatterDataBox.setEnabled(True)
        self.xDatacomboBox.setEnabled(True)
        self.xDatacomboBox.setCurrentIndex(0)
        self.rePlotInfo.update({'plotType':button.text()})
        if button.text() == 'Linear':
            self.opPointBox.setEnabled(True)
            self.scatterDataBox.setTitle('Linear Data')
            self.reconnect(self.buttonGroupScatterData.buttonClicked) #disconnecting slots
            self.reconnect(self.invTotalRadio.clicked, self.linComboboxChanged)
            self.reconnect(self.scDiodeCombo.textActivated, self.linComboboxChanged) #changing slots
            self.reconnect(self.scIgbtCombo.textActivated, self.linComboboxChanged)  #changing slots
            self.reconnect(self.xDatacomboBox.textActivated, self.xAxisChanged)
        else :
            self.opPointBox.setEnabled(False)
            self.clear()
            self.scatterDataBox.setTitle('Scatter Data')
            self.reconnect(self.buttonGroupScatterData.buttonClicked,self.updateScatterRadios) #reconnecting slots
            self.reconnect(self.scDiodeCombo.textActivated,self.scComboboxChanged) #reconnecting slots
            self.reconnect(self.scIgbtCombo.textActivated,self.scComboboxChanged) #reconnecting slots
            self.reconnect(self.xDatacomboBox.textActivated, self.replotScatter)
            self.reconnect(self.invTotalRadio.clicked) #disconnecting slot
            self.replotScatter()

           
    def reconnect(self, signal, newhandler=None, oldhandler=None):        
        try:
            if oldhandler is not None:
                while True:
                    signal.disconnect(oldhandler)
            else:
                signal.disconnect()
        except TypeError:
            pass
        if newhandler is not None:
            signal.connect(newhandler)
    
    def makeLinearPlot(self,df,ykey,xkey,key) :
        self.MplWidget.canvas.axes.clear()
        self.linAnnotKeys.clear()
        self.linAnnotKeys= [xkey, ykey]
        for key, grp in df.groupby([key]):
            l= grp.plot(ax=self.MplWidget.canvas.axes, kind='line', x=xkey, y=ykey, marker='o',grid =True, label=key)
        self.sc['linear'] = l.lines
        self.sc.pop('scatter',None)
        self.annot = self.MplWidget.canvas.axes.annotate("", xy=(0,0), xytext=(20,20),textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="w"),
                            arrowprops=dict(arrowstyle="->"))
        self.annot.set_visible(False)
        self.cid = self.MplWidget.canvas.mpl_connect('motion_notify_event', self.hover)
        self.MplWidget.canvas.axes.set_ylabel(getXisLabel(ykey))
        self.MplWidget.canvas.axes.set_xlabel(getXisLabel(xkey))
        self.MplWidget.canvas.draw()
        self.MplWidget.canvas.figure.set_visible(True)
        self.MplWidget.toolbar.show()
        print(df)


    def updateScatterRadios(self, button) :         
        yLabel = ''
        xLabel = ''
        xData = []
        yData = []
        selected = ''
        if button.text() =='Total Inverter Loss' : 
            self.scIgbtCombo.setCurrentIndex(-1) 
            self.scDiodeCombo.setCurrentIndex(-1) 
            selected = 'InvTotalLoss'
        elif button.text() == 'IGBT ':
            selected = self.scIgbtCombo.currentText()
            self.scDiodeCombo.setCurrentIndex(-1)
        elif button.text() == 'Diode':
            selected = self.scDiodeCombo.currentText()
            self.scIgbtCombo.setCurrentIndex(-1) 
        xAxisPoint = self.xDatacomboBox.currentText()   
        if selected :
            self.rePlotInfo.update({'LossTypeBtn':button, 'LossType':selected}) 
            self.data2plot['xData']= {xAxisPoint: list(self.plot_df[xAxisPoint])}                
            self.data2plot['yData']= {selected: list(self.plot_df[selected].fillna(0))}
            length = len(self.data2plot['yData'][selected])
            xLabel = getXisLabel(xAxisPoint)
            yLabel =  button.text() if 'Loss' in button.text() else button.text()+' Loss'
            self.data2plot['Dataset'] = self.plot_df
            self.plotScatter(self.data2plot['xData'],self.data2plot['yData'],xLabel,yLabel,length)

    def scComboboxChanged(self):
        sender = self.sender()
        if sender.objectName() == 'scDiodeCombo':
            self.invDiodeRadio.setChecked(True)
            self.updateScatterRadios(self.invDiodeRadio)
        elif sender.objectName() == 'scIgbtCombo':
            self.invIgbtRadio.setChecked(True)
            self.updateScatterRadios(self.invIgbtRadio)
    
    def linComboboxChanged(self):
        sender = self.sender()
        if sender.objectName() == 'invTotalRadio':
            selected = 'InvTotalLoss'
            button = self.invTotalRadio
            self.scIgbtCombo.setCurrentIndex(-1) 
            self.scDiodeCombo.setCurrentIndex(-1) 
        elif sender.objectName() == 'scDiodeCombo':
            selected = self.scDiodeCombo.currentText()
            button = self.invDiodeRadio
            self.invDiodeRadio.setChecked(True)
            self.scIgbtCombo.setCurrentIndex(-1)
        elif sender.objectName() == 'scIgbtCombo':
            selected = self.scIgbtCombo.currentText()
            button = self.invIgbtRadio
            self.invIgbtRadio.setChecked(True)
            self.scDiodeCombo.setCurrentIndex(-1)
        self.rePlotInfo.update({'LossType':selected,'LossTypeBtn':button})

    def addFilterCriteria(self):
        try :
            item = str(self.opComboType.currentText())
            input = float(self.opComboInput.text())
            global opLabelAppend
            self.filter[item] = input
            if item in self.filter:
                for key in self.filter :
                    opLabelAppend = opLabelAppend + "{} = {}\n".format("".join(key),"".join(str(self.filter[key])))
            self.opSelectDisplayLabel.setText(opLabelAppend)
            opLabelAppend = ''
            self.opComboInput.clear()
            self.opAddBtn.setText('Update')
        except :
            self.opErrorLabel.setStyleSheet("QLabel { background-color : yellow; color : red; }")
            self.opErrorLabel.setText("Invalid {} input".format("".join(str(self.opComboType.currentText()))))

    def initializeTabControls(self, DBmode):
        plotTopology = self.topologyCombo.currentText()
        if DBmode == 'Inverter':
            self.optInvBtn.setChecked(True)
            self.plotInvBtn.setChecked(True)
            df_all = pd.read_pickle(self.invfilepath)
            self.opt_df = df_all
            self.plot_df =  df_all[df_all['Topology']==plotTopology]
            self.opt_df['PWatts'] = round(self.opt_df['Load_S']*self.opt_df['Load_phi'].apply(math.cos))
            self.filterList = self.xDataInvList['V_DC'][:]
            self.opComboType.insertItems(0,self.filterList)
            self.xDatacomboBox.addItems(self.xDataInvList.keys())
        elif DBmode == 'AFE':
            self.optAfeBtn.setChecked(True)
            self.plotAFEBtn.setChecked(True)
            df_all = pd.read_pickle(self.afefilepath)
            self.opt_df = df_all
            self.plot_df =  df_all[df_all['Topology']==plotTopology]
            self.opt_df['PWatts'] = round(self.opt_df['Mains_S']* self.opt_df['Mains_phi'].apply(math.cos))
            self.filterList= self.xDataAFEList['V_DC'][:]
            self.opComboType.insertItems(0,self.filterList)
            self.xDatacomboBox.addItems(self.xDataAFEList.keys())
        self.scIgbtCombo.addItems(self.igbtList[plotTopology])
        self.scDiodeCombo.addItems(self.diodeList[plotTopology])
        self.scIgbtCombo.setCurrentIndex(-1) 
        self.scDiodeCombo.setCurrentIndex(-1)
        self.plotScRadio.setChecked(False)  
        self.plotLinRadio.setChecked(False)
        self.invTotalRadio.setChecked(False)
        self.invDiodeRadio.setChecked(False) 
        self.invIgbtRadio.setChecked(False) 
        self.opPointBox.setEnabled(False)  
        self.scatterDataBox.setEnabled(False)
        self.xDatacomboBox.setCurrentIndex(-1)
        self.xDatacomboBox.setEnabled(False)
        self.MplWidget.canvas.mpl_disconnect(self.cid)
        self.MplWidget.canvas.figure.set_visible(False)
        self.OptimalChartArea.canvas.figure.set_visible(False)
        self.MplWidget.toolbar.hide()
        self.OptimalChartArea.toolbar.hide()
        
    def resetControls(self):
        df_all = pd.read_pickle(self.invfilepath)
        self.plotInvBtn.setChecked(True)
        plotTopology = self.topologyCombo.currentText()
        self.plot_df =  df_all[df_all['Topology']==plotTopology]
        self.MplWidget.canvas.mpl_disconnect(self.cid)
        self.scIgbtCombo.clear()
        self.scDiodeCombo.clear()
        self.opComboType.clear()
        self.xDatacomboBox.clear()
        self.rePlotInfo={}
        self.scIgbtCombo.addItems(self.igbtList[plotTopology])
        self.scDiodeCombo.addItems(self.diodeList[plotTopology])
        self.filterList = self.xDataInvList['V_DC']
        self.xDatacomboBox.addItems(self.xDataInvList.keys())
        self.opComboType.insertItems(0,self.filterList)
        self.scIgbtCombo.setCurrentIndex(-1) 
        self.scDiodeCombo.setCurrentIndex(-1)
        self.xDatacomboBox.setCurrentIndex(-1)
        self.xDatacomboBox.setEnabled(False)
        button = self.buttonGroupPlotType.checkedButton()
        if button :
            self.buttonGroupPlotType.setExclusive(False)
            button.setChecked(False)
            self.buttonGroupPlotType.setExclusive(True)
        button = self.buttonGroupScatterData.checkedButton()
        if button :
            self.buttonGroupScatterData.setExclusive(False)
            button.setChecked(False)
            self.buttonGroupScatterData.setExclusive(True)
        self.plotScRadio.setChecked(False)  
        self.plotLinRadio.setChecked(False)
        self.invTotalRadio.setChecked(False)
        self.invDiodeRadio.setChecked(False) 
        self.invIgbtRadio.setChecked(False) 
        self.opPointBox.setEnabled(False)  
        self.scatterDataBox.setEnabled(False)
        self.clear()
        self.MplWidget.canvas.figure.set_visible(False)
        self.MplWidget.toolbar.hide()
        
    def plotScatter(self,xData,yData,xLabel,yLabel,length):
        try :
            if len(list(xData.values())[0])==0:
                self.MplWidget.canvas.figure.set_visible(False)
                self.MplWidget.toolbar.hide()
                raise Exception('No simulations to plot')
            self.MplWidget.canvas.axes.clear()
            self.c = np.random.randint(1,5,size=length)
            self.norm = plt.Normalize(1,4)
            self.cmap = plt.cm.RdYlGn
            self.sc['scatter'] = self.MplWidget.canvas.axes.scatter(list(xData.values()), list(yData.values()),c=self.c, s=10, cmap=self.cmap, norm=self.norm)
            self.sc.pop('linear', None)
            self.MplWidget.canvas.axes.set_xlabel(xLabel)
            self.MplWidget.canvas.axes.set_ylabel(yLabel)
            self.annot = self.MplWidget.canvas.axes.annotate("", xy=(0,0), xytext=(15,15), va='top', textcoords="offset points",
                                bbox=dict(boxstyle="round", fc="w"),
                                arrowprops=dict(arrowstyle="->"))
            self.annot.set_visible(False)
            self.cid = self.MplWidget.canvas.mpl_connect('motion_notify_event', self.hover) 
            self.MplWidget.canvas.figure.set_visible(True)
            self.MplWidget.toolbar.show()
            self.MplWidget.canvas.draw()
        except Exception as e:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText(str(e.args[0]))
            msgBox.exec()
        
    def update_scatter_annot(self,sc,ind):
        pos = sc.get_offsets()[ind]
        self.annot.xy = pos 
        OpPoint = self.data2plot['Dataset'][(self.data2plot['Dataset'][[*self.data2plot['xData']][0]] == pos[0]) & (self.data2plot['Dataset'][[*self.data2plot['yData']][0]] == pos[1])]

        text = "V_DC :{},\nTLoss:{},\nLoad :{},\nPhi    :{},\nFsw   :{}".format("".join(str(OpPoint.iloc[0]['V_DC'])),"".join(str(round(OpPoint.iloc[0]['InvTotalLoss'],2))),
                                       "".join(str(OpPoint.iloc[0]['Load_S'])),"".join(str(OpPoint.iloc[0]['Load_phi'])),
                                       "".join(str(OpPoint.iloc[0]['f_s'])))
        self.annot.set_text(text)
        self.annot.get_bbox_patch().set_facecolor(self.cmap(self.norm(self.c[ind])))
        self.annot.get_bbox_patch().set_alpha(0.4)

    def update_linear_annot(self, line,idx) : 
        posx, posy = [line.get_xdata()[idx], line.get_ydata()[idx]]
        self.annot.xy = (posx, posy)
        leg = line.axes.get_legend()
        ind = line.axes.get_lines().index(line)
        legendValue = leg.texts[ind].get_text()
        index = set(self.filterList)-self.filter.keys()
        key = self.filterList[2] if index == set() else index.pop()
        text = f'{key} :{legendValue},\n{self.linAnnotKeys[0]} :{posx:.2f},\n{self.linAnnotKeys[1]} :{posy:.2f}'
        self.annot.set_text(text)
        # annot.get_bbox_patch().set_facecolor(cmap(norm(c[ind["ind"][0]])))
        self.annot.get_bbox_patch().set_alpha(0.4)

    def hover(self,event):
        vis = self.annot.get_visible()
        (key,lines),*rest = self.sc.items()
        lines = lines if isinstance(lines, list) else [lines]
        if event.inaxes == self.MplWidget.canvas.axes:
            for plotLine in lines :
                cont, ind = plotLine.contains(event)
                if cont:
                    if key == 'linear':
                        self.update_linear_annot(plotLine, ind['ind'][0])
                    if key == 'scatter':
                        self.update_scatter_annot(plotLine,ind['ind'][0])
                    self.annot.set_visible(True)
                    self.MplWidget.canvas.draw_idle()
                else:
                    if vis:
                        self.annot.set_visible(False)
                        self.MplWidget.canvas.draw_idle()
        

    def onChange(self, ord):
        if ord ==1:
            self.optRangeControls.hide()
            self.resize(970,525)
            self.plotControls.show()
        elif ord == 2:
            self.plotControls.hide()
            self.resize(1070,525)
            self.optRangeControls.show()  
        else :
            self.plotControls.hide()
            self.optRangeControls.hide()
            self.adjustSize()


    def checkThermalParams(self,df):
        def checkIfExists(sheetList):
            isthere = False
            for sheet in sheetList:
                isthere = ~isthere 
                isthere = isthere and sheet in df.index
            return isthere
        return checkIfExists


    def simulate(self):       
        try :
            dcVltgList = self.dcVltgIn.toPlainText()
            dcVltgList = re.split(',|\s+|;|\n',dcVltgList)
            dcVltgListNew = [int(i) for i in dcVltgList]
            loadWInList = self.loadWIn.toPlainText()
            loadWInList = re.split(',|\s+|;|\n',loadWInList)
            loadWInListNew = [float(i) for i in loadWInList]
            pfDegreeInList = self.pfDegreeIn.toPlainText()
            pfDegreeInList = re.split(',|\s+|;|\n',pfDegreeInList)
            pfDegreeInListNew = [float(i) for i in pfDegreeInList]
            switchFreqInList = self.switchFreqIn.toPlainText()
            switchFreqInList = re.split(',|\s+|;|\n',switchFreqInList)
            switchFreqInListNew = [int(i) for i in switchFreqInList]
            tempInList = self.tempIn.toPlainText()
            tempInList = re.split(',|\s+|;|\n',tempInList)
            tempInListNew = [int(i) for i in tempInList]
            fOutList = self.fOutIn.toPlainText()
            fOutList = re.split(',|\s+|;|\n',fOutList)
            fOutListNew = [int(i) for i in fOutList]
            dataSheets = self.dataSheetComboBox.checkedItems()
            if dataSheets == []:
                raise Exception('Please select atleast one Datasheet!\n(Hint : Check should appear)')
            paramsContainer = {'V_DC':dcVltgListNew,'Load_S':loadWInListNew,'Load_phi':pfDegreeInListNew,'Mains_S':loadWInListNew,'Mains_phi':pfDegreeInListNew,'f_s':switchFreqInListNew,'f_out':fOutListNew,
                               'T_HS':tempInListNew,'dataSheets':dataSheets}
            for x in paramsContainer:
                #result = True
                #if x=='Transistor' or x == 'Transistor_revD' or x== 'Transistor_fwD':
                #    result = not(any([re.search("^\s*$", elem) for elem in paramsContainer[x]]))
                #if paramsContainer[x] and result :
                print(x + ' = '+ str(paramsContainer[x])+':Accepted')
            self.statusWriteLabel.setStyleSheet("QLabel { background-color : green; color : black; }")
            self.statusWriteLabel.setText('Inputs are good')
            if os.path.exists(self.Tfilepath) :
                df = pd.read_csv(self.Tfilepath,index_col =['Datasheet'])
                checkIf = self.checkThermalParams(df)
                totalSheets = self.loadThermalBox(True)
                if not checkIf(totalSheets):
                    raise Exception('Check the Thermal Params')
            else :
                raise Exception('Thermal params file not found')
            self.statusWriteLabel.adjustSize()
            saveData = self.saveLossData.isChecked()
            isAFEselected = self.AFEModeBtn.isChecked()
            topology = self.buttonGroupTopology.checkedButton().text()
            createobj = startConnection(paramsContainer,saveData,isAFEselected, topology)
            createobj.gismsUpdate.connect(self.updateGSIMS)
            createobj.progressUpdate.connect(self.updateProgressBar)
            createobj.tabsDFUpdate.connect(self.updateTabsDF)
            #createobj.eventemit()
            self.progressBar.show()
            self.progressBar.setValue(1)
            self.progressBar.setMaximum(100)
            test_thread = threading.Thread(target = createobj.initiateConnection)
            test_thread.start()
        except ValueError:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText("Please check the inputs provided")
            msgBox.exec()
        except Exception as e:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText(str(e.args[0]))
            msgBox.exec()
        except :
            errorOutput = 'unexpected error : '+ str( sys.exc_info()[0])
            print(errorOutput)
            self.statusWriteLabel.setStyleSheet("QLabel { background-color : red; color : blue; }")
            self.statusWriteLabel.setText('Please check the inputs provided\n'+ str( sys.exc_info()[0]))
            self.statusWriteLabel.adjustSize()
   

    def showGSIMSData(self):
        if(self.showGSIMS.isChecked()):
            self.gridLayoutWidget.show()
            self.topologyPicture.hide()
        else:
            self.gridLayoutWidget.hide()
            self.topologyPicture.show()
    
            
    @QtCore.pyqtSlot(dict)
    def updateGSIMS(self,out):
        if out :
            self.invCosPhiOut.setText(str(round(out['cos_phi_inv'],3)))
            self.modulationOut.setText(str(round(out['m'],3)))
            self.peakRlcCurrentOut.setText(str(round(out['I_Peak_inv'],2)))
            self.cCurrentOut.setText(str(round(out['I_Filter_C'],2)))
            self.lVltgOut.setText(str(round(out['U_Filter_L'],2)))
            self.invVtlgOut.setText(str(out['U_RMS_inv']))
            if self.AFEModeBtn.isChecked():
                self.loadVltgOut.setText(str(round(out['U_Mains_LL'],2)))
                self.loadZOut.setText(str(complex(round(out['Z_Inv'].real,2),round(out['Z_Inv'].imag,2))))
            else :
                self.loadVltgOut.setText(str(round(out['U_Load_LL'],2)))
                self.loadZOut.setText(str(complex(round(out['Z_Load'].real,2),round(out['Z_Load'].imag,2))))
        else :
            self.invCosPhiOut.setText('')
            self.modulationOut.setText('')
            self.peakRlcCurrentOut.setText('')
            self.cCurrentOut.setText('')
            self.lVltgOut.setText('')
            self.invVtlgOut.setText('')
            self.loadVltgOut.setText('')
            self.loadZOut.setText('')
            
    @QtCore.pyqtSlot(str)
    def updateTabsDF(self,mode) :  
        if not (self.tabWidget.isTabEnabled(1) or self.tabWidget.isTabEnabled(2)):
            self.tabWidget.setTabEnabled(1,True)
            self.tabWidget.setTabEnabled(2,True)
            self.initializeTabControls(mode)  ## need to recheck the inplementation
        optModeBtn =  self.buttonGroupOptMode.checkedButton()
        plotModeBtn = self.buttonGroupPlotMode.checkedButton()
        self.optChangeDb(optModeBtn)
        self.plotChangeDb(plotModeBtn)

    @QtCore.pyqtSlot(int,str)
    def updateProgressBar(self,value,text) :
        if value==-1:
            self.progressBar.setFormat(text)
        else :
            self.progressBar.setValue(value)
            self.progressBar.setFormat(text +": %v")
    

    def openDataBase(self):
        if self.dataBaseWindow is None:
            self.dataBaseWindow = dataBaseClass()
        self.dataBaseWindow.show()
         

    def loadPrevParams(self, filepath, checkedMode):
        df = pd.read_pickle(filepath)
        if not df.empty:
            lastSweepParams = df.iloc[-1]
            self.dcVltgIn.setPlainText(str(lastSweepParams['V_DC']))
            if checkedMode == 'AFE':
                self.loadWIn.setPlainText(str(lastSweepParams['Mains_S']))
                self.pfDegreeIn.setPlainText(str(lastSweepParams['Mains_phi']))
            elif checkedMode == 'Inverter':
                self.loadWIn.setPlainText(str(lastSweepParams['Load_S']))
                self.pfDegreeIn.setPlainText(str(lastSweepParams['Load_phi']))
            self.switchFreqIn.setPlainText(str(lastSweepParams['f_s']))
            self.tempIn.setPlainText(str(lastSweepParams['T_HS']))
            self.fOutIn.setPlainText(str(lastSweepParams['f_out']))
        else :
            self.dcVltgIn.clear()
            self.loadWIn.clear()
            self.pfDegreeIn.clear()
            self.switchFreqIn.clear()
            self.tempIn.clear()
            self.fOutIn.clear()
       

    #def switchCase(self,x):
    #        return {
    #         'toolButtonIGBT': self.igbtDataIn.toPlainText(),
    #         'toolButtonFW': self.fwDataIn.toPlainText(),
    #         'toolButtonRev': self.revDataIn.toPlainText()
    #        }.get(x, [])

   
    def loadThermalBox(self,isInnerCall):
        try :
            datasheets = []
            selectedSheets = self.dataSheetComboBox.checkedItems()
            if not selectedSheets :
                raise Exception('Select atleast one Datasheet!')
            df = pd.read_csv(self.datasheetpath)
            topology = self.buttonGroupTopology.checkedButton().text()
            for datasheet in selectedSheets:
                datasheets = datasheets+df[(df['Topology'] == topology)&(df['Datasheet']==datasheet)][['T1','T2','T3','T4','D1','D2','D3','D4','D5','D6']].values.tolist()
            datasheets = list(itertools.chain.from_iterable(datasheets))
            array = np.array(datasheets)
            array = array[array!='nan']
            datasheets = np.unique(array).tolist()
            if not isInnerCall:
                self.thermalWindow = thermalParamClass(datasheets)  #always expects non emtpy datasheets else is [] is given then unchecked error type returns
                self.thermalWindow.show()
            else :
                return datasheets
        except Exception as e:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setText(str(e.args[0]))
            msgBox.exec()

def getXisLabel(x):
    return {
        'V_DC': 'Dc Link Voltage',
        'f_s': 'Switching Frequency',
        'Load_phi': 'Load power factor(in deg)',
        'Load_S': 'Apparent Load Power(in W)',
        'Mains_phi': 'Mains power factor(in deg)',
        'Mains_S': 'Apparent Mains Power(in W)',
        'InvTotalLoss' : 'Total Losses(in W)'
    }.get(x, x+' Loss(in W)')                
                 
if __name__ == "__main__":
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    try:
        sys.exit(app.exec_())
    except SystemExit:
        print('Closing Window....')

